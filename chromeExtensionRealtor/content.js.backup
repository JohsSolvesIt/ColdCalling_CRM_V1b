// Content script for extracting data from Realtor.com - VERSION 2.1
// Modularized version - Phase 1 Complete

console.log('üü¢ CONTENT SCRIPT STARTING TO LOAD...');

// Import core modules (Note: These are loaded via manifest.json in correct order)
// Logging utilities, polling manager, and database service are now modular

// Reduced dependency checks - modules are optional
console.log('üöÄ Realtor Data Extractor content script loading...');

// ContentPollingManager class has been moved to modules/core/polling-manager.js

// DatabaseService class has been moved to modules/core/database-service.js

// ===== REVIEWS EXTRACTOR CLASS =====
// Modularized reviews and recommendations extraction functionality
// This will be moved to: modules/extractors/reviews-extractor.js

// ReviewsExtractor is now in modules/extractors/reviews-extractor.js
// This creates a delegation to the external module
class ReviewsExtractor {
  constructor() {
    this.externalExtractor = new window.ReviewsExtractor();
  }

  extractReviews() {
    return this.externalExtractor.extractReviews();
  }

  // Delegate all methods to the external module
  isValidReviewContent(text) {
    return this.externalExtractor.isValidReviewContent(text);
  }

  extractOverallRating(reviews) {
    return this.externalExtractor.extractOverallRating(reviews);
  }

  extractReviewCount(reviews) {
    return this.externalExtractor.extractReviewCount(reviews);
  }

  extractIndividualReviewsStructural(reviews) {
    return this.externalExtractor.extractIndividualReviewsStructural(reviews);
  }

  extractReviewsByTextPatterns(reviews, pageText) {
    return this.externalExtractor.extractReviewsByTextPatterns(reviews, pageText);
  }

  extractRecommendations(reviews) {
    return this.externalExtractor.extractRecommendations(reviews);
  }

  extractRecommendationsFromGenericPage(reviews) {
    return this.externalExtractor.extractRecommendationsFromGenericPage(reviews);
  }

  // Helper methods
  calculateTextSimilarity(text1, text2) {
    return this.externalExtractor.calculateTextSimilarity(text1, text2);
  }

  looksLikeName(text) {
    return this.externalExtractor.looksLikeName(text);
  }

  extractAuthorFromElement(element) {
    return this.externalExtractor.extractAuthorFromElement(element);
  }

  getTextContent(selectors, parentElement = document) {
    return this.externalExtractor.getTextContent(selectors, parentElement);
  }

  cleanTextForCSV(text) {
    return this.externalExtractor.cleanTextForCSV(text);
  }
}

class RealtorDataExtractor {
  constructor() {
    // Safety check for log object
    const safeLog = window.log || { 
      info: console.log, 
      debug: console.log, 
      warn: console.warn, 
      error: console.error 
    };
    
    safeLog.info('üöÄ Realtor Data Extractor content script loaded');
    safeLog.debug('üìç Current URL:', window.location.href);
    safeLog.debug('üìÑ Page title:', document.title);
    
    // Check module availability at runtime
    this.checkModuleAvailability();
    
    this.data = {};
    this.autoExtractionStarted = false; // Flag to prevent multiple auto-extractions
    
    // Initialize extractors with safety checks
    this.bioExtractor = window.BioExtractor ? new window.BioExtractor() : {
      async extractCleanBio() { return null; }
    };
    
    // Only run on Realtor.com pages or localhost for testing
    if (window.location.href.includes('realtor.com') || window.location.href.includes('localhost')) {
      safeLog.info('‚úÖ Valid Realtor.com page detected, initializing...');
      this.init();
    } else {
      safeLog.debug('‚ö†Ô∏è Not on a Realtor.com page, skipping initialization');
    }
  }

  checkModuleAvailability() {
    const modules = {
      'window.log': typeof window.log !== 'undefined',
      'window.ContentPollingManager': typeof window.ContentPollingManager !== 'undefined', 
      'window.ContactExtractor': typeof window.ContactExtractor !== 'undefined',
      'window.ReviewsExtractor': typeof window.ReviewsExtractor !== 'undefined',
      'window.ListingsExtractor': typeof window.ListingsExtractor !== 'undefined',
      'window.BioExtractor': typeof window.BioExtractor !== 'undefined',
      'window.PhotoExtractor': typeof window.PhotoExtractor !== 'undefined'
    };
    
    // Count available modules
    const availableCount = Object.values(modules).filter(Boolean).length;
    const totalCount = Object.keys(modules).length;
    
    if (availableCount !== totalCount) {
      console.warn(`‚ö†Ô∏è Only ${availableCount}/${totalCount} modules loaded`);
    } else {
      console.log(`‚úÖ All ${totalCount}/${totalCount} modules loaded successfully!`);
    }
    
    return modules;
  }

  init() {
    // Check for auto-extraction URL parameter
    this.checkAutoExtraction();
    
    // Listen for messages from popup
    chrome.runtime.onMessage.addListener(async (request, sender, sendResponse) => {
      if (request.action === 'ping') {
        // Simple ping response to check if content script is ready
        sendResponse({ ready: true });
        return true;
      }
      
      if (request.action === 'extractData') {
        try {
          console.log('üî• POPUP EXTRACTION REQUEST RECEIVED');
          console.log('üìç Current URL:', window.location.href);
          console.log('üìÑ Page title:', document.title);
          
          // Check if we're on a valid page
          const isRealtorPage = window.location.href.includes('realtor.com');
          
          if (!isRealtorPage) {
            throw new Error('Not on a Realtor.com page');
          }
          
          // Extract contact data using our ContactExtractor
          const contactData = this.extractContactData();
          
          console.log('üìû Extracted contact data:', contactData);
          
          // Extract agent data for the popup
          let agentData;
          try {
            agentData = await this.extractAgentData();
          } catch (error) {
            console.warn('‚ö†Ô∏è Agent data extraction failed:', error);
            agentData = { name: 'Unknown Agent' };
          }
          
          // Structure the data in the format the popup expects
          const structuredData = {
            contact: contactData,
            agent: agentData,
            office: {
              name: contactData.officeName,
              phone: contactData.officePhone,
              address: contactData.officeAddress
            }
          };
          
          console.log('üì¶ Structured data for popup:', structuredData);
          
          // Send the structured data back to popup
          sendResponse({
            success: true,
            data: structuredData,
            timestamp: new Date().toISOString(),
            url: window.location.href
          });
          
        } catch (error) {
          console.error('‚ùå POPUP EXTRACTION ERROR:', error);
          
          sendResponse({ 
            success: false, 
            error: error.message,
            timestamp: new Date().toISOString(),
            url: window.location.href
          });
        }
      }
      return true; // Keep message channel open for async response
    });
  }

  // Auto-extraction functionality for Force Scrape
  async checkAutoExtraction() {
    try {
      // Checking auto-extraction...
      
      // Prevent multiple auto-extractions
      if (this.autoExtractionStarted) {
        // Auto-extraction already started, skipping duplicate request
        return;
      }
      
      const urlParams = new URLSearchParams(window.location.search);
      const autoExtractParam = urlParams.get('autoExtract');
      
      if (autoExtractParam === 'true') {
        // Mark as started to prevent duplicates
        this.autoExtractionStarted = true;
        
        // Wait for page to be fully loaded
        if (document.readyState !== 'complete') {
          await new Promise(resolve => {
            window.addEventListener('load', resolve, { once: true });
          });
        }
        
        // Intelligent wait for key content
        await this.waitForKeyContent();
        
        // Start auto-extraction with enhanced timeout management
        this.showNotification('üöÄ Auto-Extraction Started', 'Force scrape in progress...', 'info', 2000);
        
        try {
          const extractedData = await this.extractAllDataWithTimeouts();
          // Auto-extraction completed
          
          // Force open data window
          this.forceOpenDataWindow(extractedData);
          
          // Send completion message to parent window
          if (window.opener) {
            window.opener.postMessage({
              type: 'FORCE_SCRAPE_COMPLETE',
              success: true,
              data: extractedData
            }, '*');
          }
          
          // Show completion notification
          this.showNotification('‚úÖ Auto-Extraction Complete!', 'Data extracted and window opened', 'success', 3000);
          
        } catch (error) {
          console.error('‚ùå Auto-extraction failed:', error);
          
          // Reset flag on error so retry is possible
          this.autoExtractionStarted = false;
          
          // Send error message to parent window
          if (window.opener) {
            window.opener.postMessage({
              type: 'FORCE_SCRAPE_COMPLETE',
              success: false,
              error: error.message
            }, '*');
          }
          
          this.showNotification('‚ùå Auto-Extraction Failed', error.message, 'error', 5000);
        }
      }
    } catch (error) {
      console.error('Error in auto-extraction check:', error);
      // Reset flag on error
      this.autoExtractionStarted = false;
    }
  }

  async waitForKeyContent() {
    // Intelligent content waiting started...
    const startTime = Date.now();
    
    // Look for key elements that indicate the page has loaded
    const keySelectors = [
      '[data-testid="agent-basic-details"]', // Agent details
      '.agent-contact-details', // Contact info
      '.agent-bio', // Bio section
      '[data-testid*="listing"]', // Property listings
      '.properties-section' // Properties area
    ];
    
    let attempts = 0;
    const maxAttempts = 50;
    
    while (attempts < maxAttempts) {
      // Check if any key content is visible
      const foundElements = keySelectors.filter(selector => 
        document.querySelector(selector) !== null
      );
      
      if (foundElements.length >= 2) { // At least 2 key elements found
        // Key content ready
        return;
      }
      
      attempts++;
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    // Content wait timeout
  }

  async waitForDatabaseService(maxWait = 5000) {
    // DatabaseService is now in the same file, so it should be immediately available
    log.debug('‚úÖ DatabaseService is available in same file');
    return new DatabaseService();
  }

  // SIMPLE, BULLETPROOF DATA EXTRACTION - EVERYTHING AT ONCE
  async extractAllDataWithTimeouts() {
    console.log('üöÄ STARTING COMPLETE DATA EXTRACTION...');
    
    const results = {
      agent: null,
      contact: null,
      listings: null,
      reviews: null,
      recommendations: null,
      metadata: {
        extractionStartTime: new Date().toISOString(),
        success: false
      }
    };

    try {
      // 1. AGENT DATA - Simple extraction
      console.log('üë§ Extracting agent data...');
      this.sendProgressMessage('agent', 'Extracting agent information...');
      results.agent = this.extractAgentData();
      console.log('‚úÖ Agent data:', results.agent);

      // 2. CONTACT DATA - Simple extraction (now working with our fixes)
      console.log('üìû Extracting contact data...');
      this.sendProgressMessage('contact', 'Extracting contact information...');
      results.contact = this.extractContactData();
      console.log('‚úÖ Contact data:', results.contact);

      // 3. PROPERTY LISTINGS - With images
      console.log('üè† Extracting property listings with images...');
      this.sendProgressMessage('listings', 'Extracting property listings...');
      results.listings = this.extractListingsWithImages();
      console.log('‚úÖ Listings data:', results.listings);

      // 4. REVIEWS AND RECOMMENDATIONS - Complete
      console.log('‚≠ê Extracting reviews and recommendations...');
      this.sendProgressMessage('reviews', 'Extracting reviews and recommendations...');
      results.reviews = this.extractReviews();
      results.recommendations = results.reviews?.recommendations || [];
      console.log('‚úÖ Reviews data:', results.reviews);

      // 5. SUCCESS!
      results.metadata.success = true;
      results.metadata.extractionEndTime = new Date().toISOString();
      results.metadata.totalDuration = Date.now() - new Date(results.metadata.extractionStartTime).getTime();
      
      console.log('üéâ EXTRACTION COMPLETE - ALL DATA EXTRACTED!');
      this.sendProgressMessage('completion', `‚úÖ All data extracted successfully in ${Math.round(results.metadata.totalDuration/1000)}s`);
      
      return results;

    } catch (error) {
      console.error('‚ùå EXTRACTION FAILED:', error);
      results.metadata.error = error.message;
      this.sendProgressMessage('error', `‚ùå Extraction failed: ${error.message}`);
      return results;
    }
  }

  // NEW: Extract listings with images - SIMPLE AND WORKING
  extractListingsWithImages() {
    console.log('üè† Looking for property listings with images...');
    
    const listings = {
      active: [],
      sold: []
    };

    // Find all property cards on the page
    const propertySelectors = [
      '[data-testid*="property"]',
      '[class*="property"]',
      '[class*="listing"]',
      '.PropertyCard',
      '.property-card',
      '.listing-card',
      'article',
      '[role="article"]'
    ];

    let propertyElements = [];
    for (const selector of propertySelectors) {
      const elements = document.querySelectorAll(selector);
      if (elements.length > 0) {
        propertyElements = Array.from(elements);
        console.log(`‚úÖ Found ${elements.length} properties using selector: ${selector}`);
        break;
      }
    }

    // If no specific property cards, look for any containers with images and prices
    if (propertyElements.length === 0) {
      console.log('üîç No property cards found, looking for any containers with images and prices...');
      const allContainers = document.querySelectorAll('div, article, section');
      propertyElements = Array.from(allContainers).filter(el => {
        const hasImage = el.querySelector('img');
        const hasPrice = el.textContent.includes('$') && /\$[\d,]+/.test(el.textContent);
        return hasImage && hasPrice;
      });
      console.log(`‚úÖ Found ${propertyElements.length} containers with images and prices`);
    }

    // Extract data from each property
    propertyElements.slice(0, 20).forEach((element, index) => { // Limit to 20 properties
      try {
        const property = this.extractSingleProperty(element, index);
        if (property) {
          // Determine if active or sold based on text content
          const text = element.textContent.toLowerCase();
          if (text.includes('sold') || text.includes('closed')) {
            listings.sold.push(property);
          } else {
            listings.active.push(property);
          }
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Failed to extract property ${index + 1}:`, error);
      }
    });

    console.log(`‚úÖ Extracted ${listings.active.length} active and ${listings.sold.length} sold properties`);
    return listings;
  }

  // NEW: Extract single property with images - SIMPLE
  extractSingleProperty(element, index) {
    const property = {
      id: `property_${index + 1}`,
      images: [],
      price: null,
      address: null,
      beds: null,
      baths: null,
      sqft: null,
      description: null,
      url: null
    };

    // Extract images
    const images = element.querySelectorAll('img');
    images.forEach(img => {
      if (img.src && !img.src.includes('data:') && !img.src.includes('placeholder')) {
        property.images.push({
          url: img.src,
          alt: img.alt || '',
          width: img.width || null,
          height: img.height || null
        });
      }
    });

    // Extract price
    const text = element.textContent;
    const priceMatch = text.match(/\$[\d,]+/);
    if (priceMatch) {
      property.price = priceMatch[0];
    }

    // Extract address (look for text that looks like an address)
    const addressMatch = text.match(/\d+[^$\n]*(?:Street|St|Avenue|Ave|Road|Rd|Drive|Dr|Lane|Ln|Way|Blvd|Boulevard)[^$\n]*/i);
    if (addressMatch) {
      property.address = addressMatch[0].trim();
    }

    // Extract beds, baths, sqft
    const bedsMatch = text.match(/(\d+)\s*(?:bed|br|bedroom)/i);
    if (bedsMatch) property.beds = parseInt(bedsMatch[1]);

    const bathsMatch = text.match(/(\d+(?:\.\d+)?)\s*(?:bath|ba|bathroom)/i);
    if (bathsMatch) property.baths = parseFloat(bathsMatch[1]);

    const sqftMatch = text.match(/([\d,]+)\s*(?:sq\.?\s*ft|sqft|square feet)/i);
    if (sqftMatch) property.sqft = parseInt(sqftMatch[1].replace(/,/g, ''));

    // Extract URL if it's a link
    const link = element.querySelector('a');
    if (link && link.href) {
      property.url = link.href;
    }

    // Only return if we found at least an image or price
    if (property.images.length > 0 || property.price) {
      console.log(`‚úÖ Extracted property ${index + 1}:`, property);
      return property;
    }

    return null;
  }

  // Send progress messages to frontend
  sendProgressMessage(section, status, details = null) {
    const progressData = {
      type: 'EXTRACTION_PROGRESS',
      section: section,
      status: status,
      details: details,
      timestamp: new Date().toISOString()
    };



    // Send to parent window (CRM frontend)
    if (window.opener) {
      window.opener.postMessage(progressData, '*');
    }

    // Also send to any iframe parent
    if (window.parent && window.parent !== window) {
      window.parent.postMessage(progressData, '*');
    }

    // Dispatch custom event for local handling
    window.dispatchEvent(new CustomEvent('extractionProgress', { detail: progressData }));
  }

  // Activity-based timeout wrapper - only times out when idle, not when actively working
  async extractWithActivityTimeout(extractionFn, options = {}) {
    const {
      name = 'unknown',
      maxIdleTime = 10000,
      maxTotalTime = 30000,
      activityCheckInterval = 1000,
      propertyLimit = null
    } = options;


    
    let lastActivity = Date.now();
    let totalStartTime = Date.now();
    let isActive = false;
    let result = null;
    let error = null;
    let timeoutTriggered = false;

    // Activity monitoring - watch for DOM changes, network requests, etc.
    const activityMonitor = {
      domObserver: null,
      networkActivity: false,
      
      start() {
        // Monitor DOM changes as a sign of activity
        this.domObserver = new MutationObserver(() => {
          lastActivity = Date.now();
          isActive = true;
        });
        
        this.domObserver.observe(document.body, {
          childList: true,
          subtree: true,
          attributes: true
        });

        // Monitor console output as activity (extension logging)
        const originalLog = console.log;
        console.log = (...args) => {
          if (args.some(arg => typeof arg === 'string' && (arg.includes('üîç') || arg.includes('‚úÖ') || arg.includes('üè†')))) {
            lastActivity = Date.now();
            isActive = true;
          }
          originalLog.apply(console, args);
        };
      },
      
      stop() {
        if (this.domObserver) {
          this.domObserver.disconnect();
        }
      }
    };

    // Function to send timeout message to parent window
    const sendTimeoutMessage = (type, details) => {
      const timeoutData = {
        type: 'EXTRACTION_TIMEOUT',
        timeoutType: type, // 'idle' or 'total' or 'limit'
        section: name,
        details: details,
        timestamp: new Date().toISOString()
      };



      // Send to parent window (CRM frontend)
      if (window.opener) {
        window.opener.postMessage(timeoutData, '*');
      }

      // Also send to any iframe parent
      if (window.parent && window.parent !== window) {
        window.parent.postMessage(timeoutData, '*');
      }

      // Dispatch custom event for local handling
      window.dispatchEvent(new CustomEvent('extractionTimeout', { detail: timeoutData }));
    };

    activityMonitor.start();

    // Start the extraction
    const extractionPromise = extractionFn().then(res => {
      result = res;
    }).catch(err => {
      error = err;
    });

    // Timeout monitoring loop
    const timeoutCheck = setInterval(() => {
      const now = Date.now();
      const idleTime = now - lastActivity;
      const totalTime = now - totalStartTime;

      // Reset activity flag
      if (isActive) {

        isActive = false;
      }

      // Check for total timeout (hard limit)
      if (totalTime >= maxTotalTime && !timeoutTriggered) {

        timeoutTriggered = true;
        clearInterval(timeoutCheck);
        activityMonitor.stop();
        
        sendTimeoutMessage('total', {
          totalTime: totalTime,
          maxTotalTime: maxTotalTime,
          idleTime: idleTime,
          section: name
        });

        if (!result && !error) {
          error = new Error(`Total timeout after ${totalTime}ms`);
        }
        return;
      }

      // Check for idle timeout (only when no activity)
      if (idleTime >= maxIdleTime && !timeoutTriggered) {

        timeoutTriggered = true;
        clearInterval(timeoutCheck);
        activityMonitor.stop();
        
        sendTimeoutMessage('idle', {
          idleTime: idleTime,
          maxIdleTime: maxIdleTime,
          totalTime: totalTime,
          section: name
        });

        if (!result && !error) {
          error = new Error(`Idle timeout after ${idleTime}ms of inactivity`);
        }
        return;
      }

      // For listings, check if we've hit property limit
      if (propertyLimit && name === 'listings' && result) {
        const totalProperties = (result.active?.length || 0) + (result.sold?.length || 0);
        if (totalProperties >= propertyLimit && !timeoutTriggered) {

          timeoutTriggered = true;
          clearInterval(timeoutCheck);
          activityMonitor.stop();
          
          sendTimeoutMessage('limit', {
            propertiesExtracted: totalProperties,
            propertyLimit: propertyLimit,
            totalTime: totalTime,
            section: name
          });

          return;
        }
      }

    }, activityCheckInterval);

    // Wait for extraction to complete or timeout
    await extractionPromise;
    clearInterval(timeoutCheck);
    activityMonitor.stop();

    if (error) {
      throw error;
    }

    return result;
  }

  async extractAllData() {
    try {

      log.info('üéØ Starting comprehensive data extraction...');
      


      
      // DIAGNOSTIC: Run page analysis first
      const diagnostics = this.extractPageDiagnostics();

      

      
      const pageType = this.detectPageType();

      

      const agentData = {
        url: window.location.href,
        extractedAt: new Date().toISOString(),
        pageType: pageType,
        agent: await this.safeExtractAsync(() => this.extractAgentData()), // BIO EXTRACTED HERE FIRST
        office: this.safeExtract(() => this.extractOfficeData()),
        contact: this.safeExtract(() => this.extractContactData()),
        reviews: this.safeExtract(() => this.extractReviews()), // REVIEWS AFTER BIO
        listings: await this.safeExtractAsync(() => this.extractListings()),
        specializations: this.safeExtract(() => this.extractSpecializations()),
        areasServed: this.safeExtract(() => this.extractAreasServed()),
        teamInfo: this.safeExtract(() => this.extractTeamInfo()),
        credentials: this.safeExtract(() => this.extractCredentials()),
        socialMedia: this.safeExtract(() => this.extractSocialMedia()),
        performance: this.safeExtract(() => this.extractPerformanceData()),
        images: this.safeExtract(() => this.extractAllImages())
      };


      log.debug('üìä Extraction complete. Agent Data:', agentData);
      
      // Enhanced: Log image extraction summary
      const imageSummary = {
        agentPhoto: !!agentData.images?.agentPhoto,
        teamPhoto: !!agentData.images?.teamPhoto,
        propertyImages: agentData.images?.propertyImages?.length || 0,
        galleryImages: agentData.images?.galleryImages?.length || 0,
        allPropertyPhotos: agentData.images?.allPropertyPhotos?.metadata?.totalFound || 0,
        listingsWithPhotos: agentData.images?.allPropertyPhotos?.metadata?.listingsWithPhotos || 0
      };
      

      log.debug('üñºÔ∏è Image Extraction Summary:', imageSummary);

      const listingSummary = agentData.listings?.active?.map(listing => ({
        address: listing.address?.substring(0, 30) + '...',
        photoCount: Array.isArray(listing.photos) ? listing.photos.length : (listing.image ? 1 : 0),
        hasMainImage: !!listing.image,
        photosArray: Array.isArray(listing.photos) ? listing.photos.length : 0
      })) || [];
      

      log.debug('üè† Active listings with photos:', listingSummary);
      
      // Try to use database service with improved loading check
      let dbResult = null;
      try {
        // Wait for DatabaseService to be available
        const dbService = await this.waitForDatabaseService();
        
        if (dbService) {
          // Temporarily skip duplicate check for debugging - always save/update
          log.info('üîÑ Forcing database save (duplicate check bypassed for debugging)');
          dbResult = await this.saveToDatabaseWithFeedback(dbService, agentData);
        } else {
          log.warn('‚ö†Ô∏è DatabaseService not available after waiting - continuing without database save');
          dbResult = { success: false, message: 'DatabaseService not available' };
        }
      } catch (error) {
        log.error('‚ùå Database operation failed:', error);
        dbResult = { success: false, error: error.message };
      }
      
      // Create individual property rows for CSV export (maintain backward compatibility)
      const propertyRows = this.createPropertyRows(agentData);
      
      log.debug('Extracted data summary:', {
        agent: agentData.agent?.name,
        office: agentData.office?.name,
        listingsActive: agentData.listings?.active?.length || 0,
        listingsSold: agentData.listings?.sold?.length || 0,
        propertyRowsGenerated: propertyRows.length,
        databaseSaved: dbResult?.success || false,
        sampleActiveListing: agentData.listings?.active?.[0] ? {
          price: agentData.listings.active[0].price,
          address: agentData.listings.active[0].address,
          beds: agentData.listings.active[0].beds,
          baths: agentData.listings.active[0].baths,
          image: agentData.listings.active[0].image,
          photos: `${agentData.listings.active[0].photos?.length || 0} photos`,
          propertyType: agentData.listings.active[0].propertyType
        } : null,
        imageCount: {
          gallery: agentData.images?.galleryImages?.length || 0,
          property: agentData.images?.propertyImages?.length || 0
        }
      });

      return {
        success: true,
        data: agentData,
        propertyRows: this.createPropertyRows(agentData), // Keep original for compatibility
        propertyColumns: this.createPropertyColumns(agentData), // New column format
        database: dbResult, // Database operation result
        summary: {
          agent: agentData.agent?.name || 'Unknown',
          totalListings: (agentData.listings?.active?.length || 0) + (agentData.listings?.sold?.length || 0),
          activeListings: agentData.listings?.active?.length || 0,
          soldListings: agentData.listings?.sold?.length || 0,
          reviewCount: agentData.reviews?.overall?.count || 0,
          rating: agentData.reviews?.overall?.rating || 0,
          images: {
            agent: agentData.images?.agentPhoto ? 1 : 0,
            team: agentData.images?.teamPhoto ? 1 : 0,
            gallery: agentData.images?.galleryImages?.length || 0,
            property: agentData.images?.propertyImages?.length || 0
          }
        }
      };
    } catch (error) {
      log.error('‚ùå Error in extractAllData:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async showDuplicateNotification(existingAgent) {
    return new Promise((resolve) => {
      // Try to get the popup window and show notification there
      chrome.runtime.sendMessage({
        type: 'SHOW_DUPLICATE_NOTIFICATION',
        agent: existingAgent
      }, (response) => {
        // If no popup response, automatically proceed with update (no user interaction)
        if (!response) {
          log.info(`üîÑ Auto-updating duplicate agent: ${existingAgent.name} (batch mode)`);
          // Always proceed with update during batch processing to avoid blocking
          resolve(true);
        } else {
          resolve(response.proceed);
        }
      });
    });
  }

  async saveToDatabaseWithFeedback(dbService, agentData) {
    try {
      log.debug('üíæ Saving to database...');
      
      // Prepare agent data for database
      const cleanAgentData = dbService.prepareAgentData({
        name: agentData.agent?.name,
        title: agentData.agent?.title,
        company: agentData.office?.name,
        phone: agentData.contact?.phone,
        email: agentData.contact?.email,
        address: agentData.office?.address,
        website: agentData.contact?.website,
        bio: agentData.agent?.bio || agentData.agent?.description,
        specializations: agentData.specializations,
        languages: agentData.agent?.languages,
        experience_years: agentData.agent?.experience_years,
        license_number: agentData.credentials?.license_number,
        license_state: agentData.credentials?.license_state,
        profile_image_url: agentData.images?.agentPhoto,
        social_media: agentData.socialMedia,
        ratings: agentData.reviews?.overall,
        certifications: agentData.credentials?.certifications,
        service_areas: agentData.areasServed
      }, window.location.href);
      
      // Prepare properties data
      const allListings = [
        ...(agentData.listings?.active || []),
        ...(agentData.listings?.sold || [])
      ];
      

      if (allListings.length > 0) {

      }
      
      const cleanProperties = dbService.preparePropertyData(allListings);
      

      if (cleanProperties.length > 0) {

      }
      
      // CLEANUP REVIEWS BEFORE DATABASE SAVE - Remove rating categories
      const cleanedReviews = { ...agentData.reviews };
      if (cleanedReviews.recommendations) {
        const beforeDbCleanup = cleanedReviews.recommendations.length;
        cleanedReviews.recommendations = cleanedReviews.recommendations.filter(rec => {
          const isRatingCategory = this.isRatingCategoryOnly(rec.text);
          if (isRatingCategory) {
            log.recommendation(`üö´ DB-SAVE CLEANUP: Removing rating category - "${rec.text}" by ${rec.author}`);
            return false;
          }
          return true;
        });
        
        const afterDbCleanup = cleanedReviews.recommendations.length;
        if (beforeDbCleanup !== afterDbCleanup) {
          log.recommendation(`üßπ DB-SAVE: Cleaned ${beforeDbCleanup - afterDbCleanup} rating categories before database save`);
        }
      }
      
      // Save to database
      const result = await dbService.saveExtractedData(
        window.location.href,
        agentData.pageType,
        cleanAgentData,
        cleanProperties,
        {
          extractionMethod: 'chrome_extension',
          dataVersion: '1.0',
          performance: agentData.performance,
          reviews: cleanedReviews
        }
      );
      
      // Show success notification
      this.showNotification('‚úÖ Database Save Successful', 
        `Agent: ${cleanAgentData.name}\nProperties: ${cleanProperties.length}`, 'success');
      
      return result;
      
    } catch (error) {
      log.error('Database save error:', error);
      
      // Show error notification but don't fail the extraction
      this.showNotification('‚ö†Ô∏è Database Save Failed', 
        'Data was extracted but not saved to database. Check console for details.', 'warning');
      
      return { success: false, error: error.message };
    }
  }

  showNotification(title, message = '', type = 'info', duration = 3000) {
    // Handle single argument case (just message)
    if (typeof title === 'string' && !message && !type) {
      // Check if it looks like HTML
      if (title.includes('<br>') || title.includes('<')) {
        message = title;
        title = 'Notification';
      } else {
        message = title;
        title = 'Notification';
      }
    }

    // Create notification element
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 10001;
      background: ${type === 'success' ? '#4CAF50' : type === 'warning' ? '#FF9800' : type === 'error' ? '#f44336' : '#2196F3'};
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      max-width: 350px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      line-height: 1.4;
    `;
    
    // Support HTML content
    notification.innerHTML = `
      <div style="font-weight: bold; margin-bottom: 5px;">${title}</div>
      <div style="font-size: 12px; opacity: 0.9;">${message}</div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
      notification.style.transform = 'translateX(0)';
    }, 100);
    
    // Animate out and remove using custom duration
    setTimeout(() => {
      notification.style.transform = 'translateX(100%)';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }, duration);
  }

  createPropertyColumns(agentData) {
    log.debug('üèóÔ∏è Creating property columns format...');
    
    const baseAgentInfo = {
      url: agentData.url,
      extractedAt: agentData.extractedAt,
      pageType: agentData.pageType,
      agentName: agentData.agent?.name || '',
      agentPhoto: agentData.agent?.photo || '', // This should be the AGENT photo
      agentBio: this.cleanTextForCSV(agentData.agent?.bio || ''),
      agentRating: agentData.agent?.rating || '',
      agentExperience: agentData.agent?.experience || '',
      agentLicense: agentData.agent?.license || '',
      agentLanguages: Array.isArray(agentData.agent?.languages) ? agentData.agent.languages.join('; ') : '',
      officeName: agentData.office?.name || '',
      officeAddress: agentData.office?.address || '',
      officePhone: agentData.office?.phone || '',
      contactPhone: agentData.contact?.phone || '',
      contactEmail: agentData.contact?.email || '',
      contactWebsite: agentData.contact?.website || '',
      reviewsRating: agentData.reviews?.overall?.rating || '',
      reviewsCount: agentData.reviews?.overall?.count || '',
      recommendationsCount: agentData.reviews?.recommendations?.length || 0,
      // Individual Reviews Data (up to 5 reviews)
      review1_rating: agentData.reviews?.individual?.[0]?.rating || '',
      review1_text: agentData.reviews?.individual?.[0]?.text || '',
      review1_author: agentData.reviews?.individual?.[0]?.author || '',
      review1_date: agentData.reviews?.individual?.[0]?.date || '',
      review1_verified: agentData.reviews?.individual?.[0]?.verified || '',
      review1_location: agentData.reviews?.individual?.[0]?.location || '',
      review1_type: agentData.reviews?.individual?.[0]?.type || '',
      review2_rating: agentData.reviews?.individual?.[1]?.rating || '',
      review2_text: agentData.reviews?.individual?.[1]?.text || '',
      review2_author: agentData.reviews?.individual?.[1]?.author || '',
      review2_date: agentData.reviews?.individual?.[1]?.date || '',
      review2_verified: agentData.reviews?.individual?.[1]?.verified || '',
      review2_location: agentData.reviews?.individual?.[1]?.location || '',
      review2_type: agentData.reviews?.individual?.[1]?.type || '',
      review3_rating: agentData.reviews?.individual?.[2]?.rating || '',
      review3_text: agentData.reviews?.individual?.[2]?.text || '',
      review3_author: agentData.reviews?.individual?.[2]?.author || '',
      review3_date: agentData.reviews?.individual?.[2]?.date || '',
      review3_verified: agentData.reviews?.individual?.[2]?.verified || '',
      review3_location: agentData.reviews?.individual?.[2]?.location || '',
      review3_type: agentData.reviews?.individual?.[2]?.type || '',
      review4_rating: agentData.reviews?.individual?.[3]?.rating || '',
      review4_text: agentData.reviews?.individual?.[3]?.text || '',
      review4_author: agentData.reviews?.individual?.[3]?.author || '',
      review4_date: agentData.reviews?.individual?.[3]?.date || '',
      review4_verified: agentData.reviews?.individual?.[3]?.verified || '',
      review4_location: agentData.reviews?.individual?.[3]?.location || '',
      review4_type: agentData.reviews?.individual?.[3]?.type || '',
      review5_rating: agentData.reviews?.individual?.[4]?.rating || '',
      review5_text: agentData.reviews?.individual?.[4]?.text || '',
      review5_author: agentData.reviews?.individual?.[4]?.author || '',
      review5_date: agentData.reviews?.individual?.[4]?.date || '',
      review5_verified: agentData.reviews?.individual?.[4]?.verified || '',
      review5_location: agentData.reviews?.individual?.[4]?.location || '',
      review5_type: agentData.reviews?.individual?.[4]?.type || '',
      // Recommendations Data (up to 5 recommendations)
      recommendation1_text: agentData.reviews?.recommendations?.[0]?.text || '',
      recommendation1_author: agentData.reviews?.recommendations?.[0]?.author || '',
      recommendation1_date: agentData.reviews?.recommendations?.[0]?.date || '',
      recommendation1_type: agentData.reviews?.recommendations?.[0]?.type || '',
      recommendation2_text: agentData.reviews?.recommendations?.[1]?.text || '',
      recommendation2_author: agentData.reviews?.recommendations?.[1]?.author || '',
      recommendation2_date: agentData.reviews?.recommendations?.[1]?.date || '',
      recommendation2_type: agentData.reviews?.recommendations?.[1]?.type || '',
      recommendation3_text: agentData.reviews?.recommendations?.[2]?.text || '',
      recommendation3_author: agentData.reviews?.recommendations?.[2]?.author || '',
      recommendation3_date: agentData.reviews?.recommendations?.[2]?.date || '',
      recommendation3_type: agentData.reviews?.recommendations?.[2]?.type || '',
      recommendation4_text: agentData.reviews?.recommendations?.[3]?.text || '',
      recommendation4_author: agentData.reviews?.recommendations?.[3]?.author || '',
      recommendation4_date: agentData.reviews?.recommendations?.[3]?.date || '',
      recommendation4_type: agentData.reviews?.recommendations?.[3]?.type || '',
      recommendation5_text: agentData.reviews?.recommendations?.[4]?.text || '',
      recommendation5_author: agentData.reviews?.recommendations?.[4]?.author || '',
      recommendation5_date: agentData.reviews?.recommendations?.[4]?.date || '',
      recommendation5_type: agentData.reviews?.recommendations?.[4]?.type || '',
      specializations: Array.isArray(agentData.specializations) ? agentData.specializations.join('; ') : '',
      areasServed: agentData.agent?.areasServed || agentData.areasServed || '',
      teamName: agentData.teamInfo?.name || '',
      credentials: Array.isArray(agentData.credentials) ? agentData.credentials.join('; ') : '',
      facebookUrl: agentData.socialMedia?.facebook || '',
      linkedinUrl: agentData.socialMedia?.linkedin || '',
      twitterUrl: agentData.socialMedia?.twitter || '',
      instagramUrl: agentData.socialMedia?.instagram || ''
    };

    // Add columns for each property (up to 20) - INCLUDE BOTH ACTIVE AND SOLD
    const maxProperties = 20; // Increased from 10 to accommodate active + sold
    const activeListings = agentData.listings?.active || [];
    const soldListings = agentData.listings?.sold || [];
    const allListings = [...activeListings, ...soldListings]; // COMBINE BOTH TYPES
    
    log.debug(`üìä PROPERTY COLUMNS: Including ${activeListings.length} active + ${soldListings.length} sold = ${allListings.length} total`);
    
    for (let i = 0; i < maxProperties; i++) {
      const listing = allListings[i]; // NOW INCLUDES BOTH ACTIVE AND SOLD
      const propNum = i + 1;
      
      if (listing) {
        baseAgentInfo[`property${propNum}Address`] = listing.address || '';
        baseAgentInfo[`property${propNum}Price`] = listing.price || '';
        baseAgentInfo[`property${propNum}Beds`] = listing.beds || '';
        baseAgentInfo[`property${propNum}Baths`] = listing.baths || '';
        baseAgentInfo[`property${propNum}Sqft`] = listing.sqft || '';
        baseAgentInfo[`property${propNum}Type`] = listing.propertyType || '';
        baseAgentInfo[`property${propNum}Status`] = listing.status || '';
        baseAgentInfo[`property${propNum}Photo`] = Array.isArray(listing.photos) ? listing.photos[0] : (listing.image || '');
        baseAgentInfo[`property${propNum}Photos`] = Array.isArray(listing.photos) ? listing.photos.slice(0, 8).join('; ') : (listing.image || '');
        baseAgentInfo[`property${propNum}PhotoCount`] = Array.isArray(listing.photos) ? listing.photos.length : (listing.image ? 1 : 0);
        baseAgentInfo[`property${propNum}Description`] = this.cleanTextForCSV(listing.description || '');
        baseAgentInfo[`property${propNum}MLS`] = listing.mls || '';
        baseAgentInfo[`property${propNum}LotSize`] = listing.lotSize || '';
        baseAgentInfo[`property${propNum}YearBuilt`] = listing.yearBuilt || '';
      } else {
        // Empty columns for properties that don't exist
        baseAgentInfo[`property${propNum}Address`] = '';
        baseAgentInfo[`property${propNum}Price`] = '';
        baseAgentInfo[`property${propNum}Beds`] = '';
        baseAgentInfo[`property${propNum}Baths`] = '';
        baseAgentInfo[`property${propNum}Sqft`] = '';
        baseAgentInfo[`property${propNum}Type`] = '';
        baseAgentInfo[`property${propNum}Status`] = '';
        baseAgentInfo[`property${propNum}Photo`] = '';
        baseAgentInfo[`property${propNum}Photos`] = '';
        baseAgentInfo[`property${propNum}PhotoCount`] = 0;
        baseAgentInfo[`property${propNum}Description`] = '';
        baseAgentInfo[`property${propNum}MLS`] = '';
        baseAgentInfo[`property${propNum}LotSize`] = '';
        baseAgentInfo[`property${propNum}YearBuilt`] = '';
      }
    }

    log.debug('‚úÖ Property columns created with', activeListings.length, 'properties');
    return [baseAgentInfo]; // Return single row with multiple property columns
  }

  createPropertyRows(agentData) {
    const rows = [];
    const baseAgentInfo = {
      url: agentData.url,
      extractedAt: agentData.extractedAt,
      pageType: agentData.pageType,
      agentName: agentData.agent?.name || '',
      agentPhoto: agentData.agent?.photo || '', // This should be the AGENT photo
      agentBio: this.cleanTextForCSV(agentData.agent?.bio || ''),
      agentRating: agentData.agent?.rating || '',
      agentExperience: agentData.agent?.experience || '',
      agentLicense: agentData.agent?.license || '',
      agentLanguages: Array.isArray(agentData.agent?.languages) ? agentData.agent.languages.join('; ') : '',
      officeName: agentData.office?.name || '',
      officeAddress: agentData.office?.address || '',
      officePhone: agentData.office?.phone || '',
      contactPhone: agentData.contact?.phone || '',
      contactEmail: agentData.contact?.email || '',
      contactWebsite: agentData.contact?.website || '',
      reviewsRating: agentData.reviews?.overall?.rating || '',
      reviewsCount: agentData.reviews?.overall?.count || '',
      recommendationsCount: agentData.reviews?.recommendations?.length || 0,
      // Individual Reviews Data (up to 5 reviews)
      review1_rating: agentData.reviews?.individual?.[0]?.rating || '',
      review1_text: agentData.reviews?.individual?.[0]?.text || '',
      review1_author: agentData.reviews?.individual?.[0]?.author || '',
      review1_date: agentData.reviews?.individual?.[0]?.date || '',
      review1_verified: agentData.reviews?.individual?.[0]?.verified || '',
      review1_location: agentData.reviews?.individual?.[0]?.location || '',
      review1_type: agentData.reviews?.individual?.[0]?.type || '',
      review2_rating: agentData.reviews?.individual?.[1]?.rating || '',
      review2_text: agentData.reviews?.individual?.[1]?.text || '',
      review2_author: agentData.reviews?.individual?.[1]?.author || '',
      review2_date: agentData.reviews?.individual?.[1]?.date || '',
      review2_verified: agentData.reviews?.individual?.[1]?.verified || '',
      review2_location: agentData.reviews?.individual?.[1]?.location || '',
      review2_type: agentData.reviews?.individual?.[1]?.type || '',
      review3_rating: agentData.reviews?.individual?.[2]?.rating || '',
      review3_text: agentData.reviews?.individual?.[2]?.text || '',
      review3_author: agentData.reviews?.individual?.[2]?.author || '',
      review3_date: agentData.reviews?.individual?.[2]?.date || '',
      review3_verified: agentData.reviews?.individual?.[2]?.verified || '',
      review3_location: agentData.reviews?.individual?.[2]?.location || '',
      review3_type: agentData.reviews?.individual?.[2]?.type || '',
      review4_rating: agentData.reviews?.individual?.[3]?.rating || '',
      review4_text: agentData.reviews?.individual?.[3]?.text || '',
      review4_author: agentData.reviews?.individual?.[3]?.author || '',
      review4_date: agentData.reviews?.individual?.[3]?.date || '',
      review4_verified: agentData.reviews?.individual?.[3]?.verified || '',
      review4_location: agentData.reviews?.individual?.[3]?.location || '',
      review4_type: agentData.reviews?.individual?.[3]?.type || '',
      review5_rating: agentData.reviews?.individual?.[4]?.rating || '',
      review5_text: agentData.reviews?.individual?.[4]?.text || '',
      review5_author: agentData.reviews?.individual?.[4]?.author || '',
      review5_date: agentData.reviews?.individual?.[4]?.date || '',
      review5_verified: agentData.reviews?.individual?.[4]?.verified || '',
      review5_location: agentData.reviews?.individual?.[4]?.location || '',
      review5_type: agentData.reviews?.individual?.[4]?.type || '',
      // Recommendations Data (up to 5 recommendations)
      recommendation1_text: agentData.reviews?.recommendations?.[0]?.text || '',
      recommendation1_author: agentData.reviews?.recommendations?.[0]?.author || '',
      recommendation1_date: agentData.reviews?.recommendations?.[0]?.date || '',
      recommendation1_type: agentData.reviews?.recommendations?.[0]?.type || '',
      recommendation2_text: agentData.reviews?.recommendations?.[1]?.text || '',
      recommendation2_author: agentData.reviews?.recommendations?.[1]?.author || '',
      recommendation2_date: agentData.reviews?.recommendations?.[1]?.date || '',
      recommendation2_type: agentData.reviews?.recommendations?.[1]?.type || '',
      recommendation3_text: agentData.reviews?.recommendations?.[2]?.text || '',
      recommendation3_author: agentData.reviews?.recommendations?.[2]?.author || '',
      recommendation3_date: agentData.reviews?.recommendations?.[2]?.date || '',
      recommendation3_type: agentData.reviews?.recommendations?.[2]?.type || '',
      recommendation4_text: agentData.reviews?.recommendations?.[3]?.text || '',
      recommendation4_author: agentData.reviews?.recommendations?.[3]?.author || '',
      recommendation4_date: agentData.reviews?.recommendations?.[3]?.date || '',
      recommendation4_type: agentData.reviews?.recommendations?.[3]?.type || '',
      recommendation5_text: agentData.reviews?.recommendations?.[4]?.text || '',
      recommendation5_author: agentData.reviews?.recommendations?.[4]?.author || '',
      recommendation5_date: agentData.reviews?.recommendations?.[4]?.date || '',
      recommendation5_type: agentData.reviews?.recommendations?.[4]?.type || '',
      specializations: Array.isArray(agentData.specializations) ? agentData.specializations.join('; ') : '',
      areasServed: Array.isArray(agentData.areasServed) ? agentData.areasServed.join('; ') : '',
      teamName: agentData.teamInfo?.name || '',
      credentials: Array.isArray(agentData.credentials) ? agentData.credentials.join('; ') : '',
      facebookUrl: agentData.socialMedia?.facebook || '',
      linkedinUrl: agentData.socialMedia?.linkedin || '',
      twitterUrl: agentData.socialMedia?.twitter || '',
      instagramUrl: agentData.socialMedia?.instagram || ''
    };

    // Create rows for active listings
    if (agentData.listings?.active?.length > 0) {
      agentData.listings.active.forEach((listing, index) => {
        rows.push({
          ...baseAgentInfo,
          listingType: 'Active',
          listingIndex: index + 1,
          propertyAddress: listing.address || '',
          propertyPrice: listing.price || '',
          propertyBeds: listing.beds || '',
          propertyBaths: listing.baths || '',
          propertySqft: listing.sqft || '',
          propertyType: listing.propertyType || '',
          propertyDescription: this.cleanTextForCSV(listing.description || ''),
          propertyStatus: listing.status || '',
          propertyPhotos: Array.isArray(listing.photos) ? listing.photos.slice(0, 8).join('; ') : (listing.image || ''), // PROPERTY photos (up to 8)
          propertyPhotoCount: Array.isArray(listing.photos) ? listing.photos.length : (listing.image ? 1 : 0), // Count of photos
          propertyMainPhoto: Array.isArray(listing.photos) ? listing.photos[0] : (listing.image || ''), // Primary photo
          propertyMLS: listing.mls || '',
          propertyLotSize: listing.lotSize || '',
          propertyYearBuilt: listing.yearBuilt || ''
        });
      });
    }

    // Create rows for sold listings
    if (agentData.listings?.sold?.length > 0) {
      agentData.listings.sold.forEach((listing, index) => {
        rows.push({
          ...baseAgentInfo,
          listingType: 'Sold',
          listingIndex: index + 1,
          propertyAddress: listing.address || '',
          propertyPrice: listing.price || '',
          propertyBeds: listing.beds || '',
          propertyBaths: listing.baths || '',
          propertySqft: listing.sqft || '',
          propertyType: listing.propertyType || '',
          propertyDescription: this.cleanTextForCSV(listing.description || ''),
          propertyStatus: listing.status || '',
          propertyPhotos: Array.isArray(listing.photos) ? listing.photos.slice(0, 8).join('; ') : (listing.image || ''), // PROPERTY photos (up to 8)
          propertyPhotoCount: Array.isArray(listing.photos) ? listing.photos.length : (listing.image ? 1 : 0), // Count of photos
          propertyMainPhoto: Array.isArray(listing.photos) ? listing.photos[0] : (listing.image || ''), // Primary photo
          propertyMLS: listing.mls || '',
          propertyLotSize: listing.lotSize || '',
          propertyYearBuilt: listing.yearBuilt || ''
        });
      });
    }

    // If no listings found, create one row with just agent data
    if (rows.length === 0) {
      rows.push({
        ...baseAgentInfo,
        listingType: 'No Listings Found',
        listingIndex: 0,
        propertyAddress: '',
        propertyPrice: '',
        propertyBeds: '',
        propertyBaths: '',
        propertySqft: '',
        propertyType: '',
        propertyDescription: '',
        propertyStatus: '',
        propertyPhotos: '',
        propertyMLS: '',
        propertyLotSize: '',
        propertyYearBuilt: ''
      });
    }

    return rows;
  }

  safeExtract(extractFunction) {
    try {
      const functionName = extractFunction.toString().match(/this\.(\w+)\(/)?.[1] || 'unknown';

      
      const result = extractFunction();
      

      return result;
    } catch (error) {
      const functionName = extractFunction.toString().match(/this\.(\w+)\(/)?.[1] || 'unknown';
      console.error(`‚ùå Error in ${functionName}:`, error);
      log.error('Error in extraction function:', error);
      return {};
    }
  }

  async safeExtractAsync(extractFunction) {
    try {
      const functionName = extractFunction.toString().match(/this\.(\w+)\(/)?.[1] || 'unknown';

      
      const result = await extractFunction();
      

      return result;
    } catch (error) {
      const functionName = extractFunction.toString().match(/this\.(\w+)\(/)?.[1] || 'unknown';
      console.error(`‚ùå Error in ${functionName}:`, error);
      log.error('Error in async extraction function:', error);
      return {};
    }
  }

  detectPageType() {
    const url = window.location.href;
    if (url.includes('/realestateagents/')) return 'agent';
    if (url.includes('/realestateandhomes-search/')) return 'search';
    if (url.includes('/realestateandhomes-detail/')) return 'property';
    return 'unknown';
  }

  async extractAgentData() {

    
    // Check if AgentExtractor module is available
    if (typeof window !== 'undefined' && window.AgentExtractor) {

      const agent = window.AgentExtractor.extractAgentData();

      
      // Add bio extraction (async operation)
      try {
        agent.bio = await this.bioExtractor.extractCleanBio();
      } catch (error) {
        console.error('‚ùå Error extracting bio:', error);
        agent.bio = 'Not found';
      }

      // Add license and languages extraction
      try {
        agent.license = this.cleanText(this.getTextContent([
          '[data-testid="license-number"]',
          '.license-number',
          '.agent-license',
          '.license'
        ]));
      } catch (error) {
        console.error('‚ùå Error extracting license:', error);
        agent.license = 'Not found';
      }

      try {
        agent.languages = this.cleanText(this.getTextContent([
          '[data-testid="languages"]',
          '.languages-spoken',
          '.agent-languages',
          '.languages'
        ]));
      } catch (error) {
        console.error('‚ùå Error extracting languages:', error);
        agent.languages = 'Not found';
      }


      return agent;
    }
    
    log.error('‚ùå AgentExtractor module not available - falling back to basic extraction');
    const agent = {};
    
    // Agent name - try to get clean name only
    try {
      agent.name = this.extractCleanAgentName();

    } catch (error) {
      console.error('‚ùå Error extracting agent name:', error);
      agent.name = 'Not found';
    }

    // Profile photo - target actual agent headshot, not cover photos
    try {
      log.debug('üì∏ Looking for agent profile photo...');
      agent.photo = this.extractAgentProfilePhoto();
    } catch (error) {
      console.error('‚ùå Error extracting agent photo:', error);
      agent.photo = null;
    }

    // Bio/Description - get clean bio text (NOW ASYNC - EXPANDS "SEE MORE" FIRST)
    try {
      agent.bio = await this.bioExtractor.extractCleanBio();
    } catch (error) {
      console.error('‚ùå Error extracting bio:', error);
      agent.bio = 'Not found';
    }

    // Price range information - extract just the price range
    try {
      agent.priceRange = this.extractPriceRange();
    } catch (error) {
      console.error('‚ùå Error extracting price range:', error);
      agent.priceRange = null;
    }

    // Extract rating - clean number only
    try {
      agent.rating = this.extractRating();
    } catch (error) {
      console.error('‚ùå Error extracting rating:', error);
      agent.rating = 'Not found';
    }

    // Recommendations count - clean number only
    try {
      agent.recommendationsCount = this.extractRecommendationsCount();
    } catch (error) {
      console.error('‚ùå Error extracting recommendations count:', error);
      agent.recommendationsCount = 0;
    }

    // Years of experience
    try {
      agent.experience = this.extractExperience();
    } catch (error) {
      console.error('‚ùå Error extracting experience:', error);
      agent.experience = 'Not found';
    }
    
    // FALLBACK: If individual agent data is missing, try to use review data
    try {
      if (!agent.rating || agent.rating === 'Not found' || !agent.rating) {
        const reviewsData = this.extractReviews();
        if (reviewsData?.overall?.rating) {
          agent.rating = reviewsData.overall.rating;
          log.debug('‚úÖ Using review rating as agent rating:', agent.rating);
        }
      }
    } catch (error) {
      console.error('‚ùå Error in rating fallback:', error);
    }
    
    try {
      if (!agent.experience || agent.experience === 'Not found' || !agent.experience) {
        // Try to extract from page text
        const pageText = document.body.textContent || '';
        const expMatch = pageText.match(/(\d+)\s+years?\s+(?:of\s+)?(?:experience|in\s+real\s+estate)/i);
        if (expMatch) {
          agent.experience = expMatch[1] + ' years';
          log.debug('‚úÖ Found experience in page text:', agent.experience);
        }
      }
    } catch (error) {
      console.error('‚ùå Error in experience fallback:', error);
    }

    // License number - cleaned
    try {
      agent.license = this.cleanText(this.getTextContent([
        '[data-testid="license-number"]',
        '.license-number',
        '.agent-license',
        '.license'
      ]));
    } catch (error) {
      console.error('‚ùå Error extracting license:', error);
      agent.license = 'Not found';
    }

    // Languages spoken - cleaned
    try {
      agent.languages = this.cleanText(this.getTextContent([
        '[data-testid="languages"]',
        '.languages-spoken',
        '.agent-languages',
        '.languages'
      ]));
    } catch (error) {
      console.error('‚ùå Error extracting languages:', error);
      agent.languages = 'Not found';
    }

    // Areas served - extract geographic service areas
    try {
      agent.areasServed = this.extractAreasServed();
    } catch (error) {
      console.error('‚ùå Error extracting areas served:', error);
      agent.areasServed = '';
    }


    return agent;
  }

  extractAgentProfilePhoto() {
    // Check if AgentExtractor module is available
    if (typeof window !== 'undefined' && window.AgentExtractor) {
      return window.AgentExtractor.extractAgentProfilePhoto();
    }
    
    log.error('‚ùå AgentExtractor module not available for profile photo extraction - using fallback');
    
    // Fallback extraction - basic photo extraction
    const photoSelectors = [
      '[data-testid="agent-photo"] img',
      '.agent-photo img',
      '.profile-photo img',
      '.headshot img'
    ];

    for (const selector of photoSelectors) {
      const img = document.querySelector(selector);
      if (img && img.src) {

        return img.src;
      }
    }
    
    return null;
  }

  extractAreasServed() {
    // Check if AgentExtractor module is available
    if (typeof window !== 'undefined' && window.AgentExtractor) {
      return window.AgentExtractor.extractAreasServed();
    }
    
    log.error('‚ùå AgentExtractor module not available for areas served extraction');
    return '';
  }

  extractCleanAgentName() {
    // DISABLED AgentExtractor - using fallback only
    // Check if AgentExtractor module is available
    if (false && typeof window !== 'undefined' && window.AgentExtractor) {
      return window.AgentExtractor.extractCleanAgentName();
    }
    
    log.error('‚ùå AgentExtractor module not available for agent name extraction - using fallback');
    
    // Fallback extraction - basic name extraction
    const nameSelectors = [
      'h1[data-testid="agent-name"]',
      '.agent-name',
      'h1',
      '.profile-name'
    ];
    
    for (const selector of nameSelectors) {
      const element = document.querySelector(selector);
      if (element) {
        const text = element.textContent?.trim();
        if (text && text.length > 2 && text.length < 100) {

          return text;
        }
      }
    }
    
    // Try page title as last resort
    const title = document.title;
    if (title && title.includes('|') || title.includes('-')) {
      const parts = title.split(/[|\-]/);
      if (parts.length > 0) {
        const potentialName = parts[0].trim();
        if (potentialName.length > 2 && potentialName.length < 100) {

          return potentialName;
        }
      }
    }
    
    return 'Agent Name Not Found';
  }

  isValidName(text) {
    // Check if AgentExtractor module is available
    if (typeof window !== 'undefined' && window.AgentExtractor) {
      return window.AgentExtractor.isValidName(text);
    }
    
    log.error('‚ùå AgentExtractor module not available for name validation');
    return false;
  }

  // ANTI-SCRAPER RESISTANT: Expand "See More" content using multiple strategies
  async expandAllSeeMoreContent() {

    
    let expandedCount = 0;
    
    // Strategy 1: Look for BUTTONS first (most likely to be expansion triggers)
    const buttonSelectors = [
      'button', 
      'span[role="button"]', 
      'div[role="button"]',
      '[data-testid*="more"]',
      '[data-testid*="expand"]',
      '[aria-expanded="false"]'
    ];
    
    for (const selector of buttonSelectors) {
      try {
        const elements = document.querySelectorAll(selector);
        
        for (const element of elements) {
          const text = (element.textContent || '').toLowerCase().trim();
          
          // Only match very specific expansion text patterns
          const isExpansionButton = (
            text === 'see more' || 
            text === 'read more' || 
            text === 'show more' ||
            text === 'view more' ||
            text === 'expand' ||
            text.includes('see full bio') ||
            text.includes('read full bio') ||
            text.includes('show full bio')
          );
          
          // Also detect "See less" buttons - we want to ensure content is expanded
          const isCollapseButton = (
            text === 'see less' ||
            text === 'read less' ||
            text === 'show less' ||
            text === 'collapse'
          );
          
          // If we find a "See less" button, the content is already expanded - good!
          if (isCollapseButton) {

            // Don't click it, just note that content is expanded
            continue;
          }
          
          // CRITICAL: Exclude navigation links by checking href
          const isNavigationLink = element.href && (
            element.href.includes('/advice/') ||
            element.href.includes('/news/') ||
            element.href.includes('/blog/') ||
            element.href.includes('realtor.com/advice') ||
            element.href !== window.location.href
          );
          
          if (isExpansionButton && !isNavigationLink && element.offsetParent !== null) {


            
            try {
              element.click();
              expandedCount++;

              
              // Small delay between clicks
              if (expandedCount > 0 && expandedCount % 2 === 0) {
                break; // Don't click too many at once
              }
              
            } catch (clickError) {

            }
          } else if (isExpansionButton && isNavigationLink) {

          }
        }
        
        if (expandedCount >= 3) break; // Don't click too many
        
      } catch (error) {

      }
    }
    
    // Strategy 2: Look for clickable spans/divs near bio content (fallback)
    if (expandedCount === 0) {

      
      try {
        // Look for elements that contain bio-like content and have expansion hints
        const bioContainers = document.querySelectorAll('div, section, article');
        
        for (const container of bioContainers) {
          const containerText = (container.textContent || '').toLowerCase();
          
          // Check if this container has bio-like content
          const hasBioContent = (
            containerText.includes('broker') ||
            containerText.includes('real estate') ||
            containerText.includes('experience') ||
            containerText.includes('years')
          );
          
          if (hasBioContent) {
            // Look for expansion elements within this container
            const expansionElements = container.querySelectorAll('span, div, button');
            
            for (const element of expansionElements) {
              const text = (element.textContent || '').toLowerCase().trim();
              
              if ((text === 'see more' || text === 'read more') && 
                  !element.href && 
                  element.offsetParent !== null) {
                

                
                try {
                  element.click();
                  expandedCount++;

                  break; // Only click one per container
                } catch (clickError) {

                }
              }
            }
          }
        }
      } catch (error) {

      }
    }
    

    
    // Poll for content readiness instead of fixed delay
    if (expandedCount > 0) {

      const isReady = await ContentPollingManager.pollForBioExpansion(expandedCount, {
        maxAttempts: 30,
        interval: 50,
        timeout: 2000
      });
      
      if (isReady) {

      } else {

      }
    } else {

    }
    
    return expandedCount;
  }

  // DIAGNOSTIC FUNCTION: Extract raw page structure
  extractPageDiagnostics() {

    
    // 1. Check for all h1, h2, h3 elements
    const headings = [];
    ['h1', 'h2', 'h3'].forEach(tag => {
      document.querySelectorAll(tag).forEach(el => {
        headings.push({
          tag: tag,
          text: el.textContent?.trim().substring(0, 100),
          className: el.className,
          id: el.id
        });
      });
    });

    
    // 2. Check for elements that might contain addresses
    const addressLikeElements = [];
    document.querySelectorAll('*').forEach(el => {
      const text = el.textContent || '';
      if ((text.includes('Camarillo') || text.includes('CA') || text.includes('93012') || text.includes('93010')) && 
          text.length < 200) {
        addressLikeElements.push({
          tagName: el.tagName,
          className: el.className,
          text: text.trim().substring(0, 150)
        });
      }
    });

    
    // 3. Check for common agent data patterns
    const dataTestIds = [];
    document.querySelectorAll('[data-testid]').forEach(el => {
      dataTestIds.push({
        testId: el.getAttribute('data-testid'),
        text: el.textContent?.trim().substring(0, 100),
        tagName: el.tagName
      });
    });

    
    return {
      headings,
      addressLikeElements: addressLikeElements.slice(0, 10),
      dataTestIds: dataTestIds.slice(0, 20)
    };
  }

  // Helper method to check for mixed content
  containsMixedContent(text) {
    const mixedContentIndicators = [
      'cookie', 'privacy', 'terms', 'javascript', 'copyright',
      'navigation', 'menu', 'footer', 'header', 'sidebar'
    ];
    
    const lowerText = text.toLowerCase();
    return mixedContentIndicators.some(indicator => lowerText.includes(indicator));
  }

  extractPriceRange() {
    // Check if AgentExtractor module is available
    if (typeof window !== 'undefined' && window.AgentExtractor) {
      return window.AgentExtractor.extractPriceRange();
    }
    
    log.error('‚ùå AgentExtractor module not available for price range extraction');
    const pageText = document.body.textContent;
    const priceMatch = pageText.match(/\$[\d,]+\s*-\s*\$[\d,]+[KM]?/);
    return priceMatch ? priceMatch[0] : null;
  }

  extractRating() {
    // DISABLED AgentExtractor - using fallback only
    // Check if AgentExtractor module is available
    if (false && typeof window !== 'undefined' && window.AgentExtractor) {
      return window.AgentExtractor.extractRating();
    }
    
    log.debug('‚ùå AgentExtractor disabled - using rating fallback');
    
    // Fallback rating extraction
    const ratingSelectors = [
      '[data-testid="agent-rating"]',
      '.agent-rating',
      '.rating',
      '.star-rating'
    ];
    
    for (const selector of ratingSelectors) {
      const element = document.querySelector(selector);
      if (element) {
        const text = element.textContent?.trim();
        const rating = parseFloat(text);
        if (!isNaN(rating) && rating >= 0 && rating <= 5) {
          return rating;
        }
      }
    }
    
    // Try to find rating in page text
    const pageText = document.body.textContent;
    const ratingMatch = pageText.match(/(\d+(?:\.\d+)?)\s*(?:star|‚òÖ|‚≠ê)/i);
    if (ratingMatch) {
      const rating = parseFloat(ratingMatch[1]);
      if (!isNaN(rating) && rating >= 0 && rating <= 5) {
        return rating;
      }
    }
    
    return null;
  }

  extractRecommendationsCount() {
    // Check if AgentExtractor module is available
    if (typeof window !== 'undefined' && window.AgentExtractor) {
      return window.AgentExtractor.extractRecommendationsCount();
    }
    
    log.error('‚ùå AgentExtractor module not available for recommendations count extraction');
    const pageText = document.body.textContent;
    const recMatch = pageText.match(/(\d+)\s+recommendations/);
    return recMatch ? recMatch[1] : null;
  }

  extractExperience() {
    // DISABLED AgentExtractor - using fallback only
    // Check if AgentExtractor module is available
    if (false && typeof window !== 'undefined' && window.AgentExtractor) {
      return window.AgentExtractor.extractExperience();
    }
    
    log.debug('‚ùå AgentExtractor disabled - using experience fallback');
    
    // Fallback experience extraction
    const pageText = document.body.textContent;
    
    // Look for "X years" pattern
    const experiencePatterns = [
      /(\d+)\s+years?\s+(?:of\s+)?experience/i,
      /(\d+)\s+years?\s+in\s+real\s+estate/i,
      /experience:\s*(\d+)\s+years?/i,
      /(\d+)\+?\s*years?\s+agent/i
    ];
    
    for (const pattern of experiencePatterns) {
      const match = pageText.match(pattern);
      if (match) {
        const years = parseInt(match[1]);
        if (!isNaN(years) && years > 0 && years < 100) {
          return `${years} years`;
        }
      }
    }
    
    return null;
  }

  extractOfficeData() {
    console.error('üîç TESTING: extractOfficeData called');
    
    // BYPASS MODULE SYSTEM - TEST DIRECT EXTRACTION
    const office = {};
    
    // Simple office name test - look for RE/MAX, Coldwell Banker, etc.
    const pageText = document.body.textContent;
    
    const officePatterns = [
      /RE\/MAX[^,.\n]{0,30}/gi,
      /Coldwell Banker[^,.\n]{0,30}/gi,
      /Century 21[^,.\n]{0,30}/gi,
      /Keller Williams[^,.\n]{0,30}/gi
    ];
    
    for (const pattern of officePatterns) {
      const match = pageText.match(pattern);
      if (match) {
        console.error('‚úÖ FOUND OFFICE PATTERN:', match[0]);
        office.name = match[0].trim();
        break;
      }
    }
    
    if (!office.name) {
      console.error('‚ùå NO OFFICE PATTERN FOUND');
      office.name = null;
    }
    
    console.error('üîç FINAL OFFICE DATA:', office);
    return office;
    
    // Office/Brokerage name - extract clean office name only
    office.name = this.extractCleanOfficeName();

    // Office address
    office.address = this.cleanText(this.getTextContent([
      '[data-testid="office-address"]',
      '.office-address',
      '.brokerage-address',
      '.company-address',
      '.address',
      '.office-location'
    ]));

    // Office phone
    office.phone = this.cleanPhoneNumber(this.getTextContent([
      '[data-testid="office-phone"]',
      '.office-phone',
      '.brokerage-phone',
      '.company-phone',
      '.office-contact'
    ]));

    return office;
  }

  extractCleanOfficeName() {
    // Look for RE/MAX Infinity specifically
    const pageText = document.body.textContent;
    if (pageText.includes('RE/MAX Infinity')) {
      return 'RE/MAX Infinity';
    }
    
    // Try to find other brokerage patterns
    const brokerageMatch = pageText.match(/([A-Z][A-Za-z\s&]+(?:Realty|Real Estate|Properties|Group|Associates|Team))/);
    if (brokerageMatch) {
      const name = brokerageMatch[1].trim();
      if (name.length < 50 && !this.containsMixedContent(name)) {
        return name;
      }
    }
    
    // Look in structured elements with specific text extraction
    const officeSelectors = [
      '[data-testid="office-name"]',
      '.office-name',
      '.brokerage-name',
      '.company-name'
    ];
    
    for (const selector of officeSelectors) {
      const element = document.querySelector(selector);
      if (element) {
        const name = this.extractSpecificText(element, 100);
        if (name && name.length < 100 && !this.containsMixedContent(name)) {
          return name;
        }
      }
    }
    
    return null;
  }

  extractContactData() {
    log.debug('üìû Extracting contact information directly...');
    
    const contact = {};
    
    // Phone extraction - direct and simple
    contact.phone = this.extractCleanPhone();
    contact.officePhone = this.extractOfficePhone();
    contact.mobilePhone = this.extractMobilePhone();
    
    // Email extraction - direct
    contact.email = this.extractCleanEmail();
    
    // Website extraction - direct
    contact.website = this.extractWebsiteUrl();
    
    // Office name extraction - SIMPLE AND DIRECT
    contact.officeName = this.extractOfficeName();
    
    // Office address extraction - SIMPLE AND DIRECT  
    contact.officeAddress = this.extractOfficeAddress();
    
    log.debug('üìä Direct extraction results:', contact);
    return contact;
  }

  // NEW: Simple office name extraction
  extractOfficeName() {
    log.debug('üè¢ Looking for office name...');
    
    // Strategy 1: Get from URL (most reliable for Masiello)
    const url = window.location.href;
    const urlMatch = url.match(/\/\/(?:www\.)?([a-zA-Z]+)\.([a-zA-Z]+)\.com/);
    if (urlMatch) {
      const company = urlMatch[2]; // "masiello" from beckyprescott.masiello.com
      if (company && company.length > 3) {
        const officeName = company.charAt(0).toUpperCase() + company.slice(1);
        log.debug(`‚úÖ Found office from URL: ${officeName}`);
        return officeName;
      }
    }
    
    // Strategy 2: Look for "Masiello" specifically in page text
    const pageText = document.body.textContent;
    if (pageText.includes('Masiello')) {
      log.debug('‚úÖ Found office name: Masiello');
      return 'Masiello';
    }
    
    // Strategy 3: Look for other major companies
    const companies = ['RE/MAX', 'Coldwell Banker', 'Century 21', 'Keller Williams', 'Compass', 'Berkshire Hathaway'];
    for (const company of companies) {
      if (pageText.includes(company)) {
        log.debug(`‚úÖ Found office name: ${company}`);
        return company;
      }
    }
    
    log.debug('‚ùå No office name found');
    return null;
  }

  // NEW: Simple office address extraction
  extractOfficeAddress() {
    log.debug('üè¢ Looking for office address...');
    
    const pageText = document.body.textContent;
    
    // Look for address patterns
    const addressPattern = /\d+\s+[A-Za-z\s,]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Lane|Ln)\s*,?\s*[A-Za-z\s]+,?\s*[A-Z]{2}\s+\d{5}/g;
    const matches = pageText.match(addressPattern);
    
    if (matches && matches.length > 0) {
      const address = matches[0].trim();
      log.debug(`‚úÖ Found office address: ${address}`);
      return address;
    }
    
    log.debug('‚ùå No office address found');
    return null;
  }


  extractCleanPhone() {
    log.debug('üìû Looking for phone numbers...');
    
    // Enhanced phone selectors
    const phoneSelectors = [
      '[data-testid="phone"]',
      '[data-testid="agent-phone"]',
      '.phone',
      '.agent-phone',
      '.contact-phone',
      '.phone-number',
      'a[href^="tel:"]',
      '[href*="tel:"]',
      '.contact-info .phone',
      '.agent-contact .phone'
    ];
    
    // Try specific phone elements first
    for (const selector of phoneSelectors) {
      const elements = document.querySelectorAll(selector);
      for (const element of elements) {
        let phone = null;
        
        // Check href attribute for tel: links
        if (element.href && element.href.startsWith('tel:')) {
          phone = element.href.replace('tel:', '').trim();
        } else {
          phone = element.textContent?.trim();
        }
        
        log.debug(`üìû Testing phone from ${selector}: "${phone}"`);
        
        if (phone) {
          const cleanPhone = this.cleanPhoneNumber(phone);
          if (cleanPhone && this.isValidPhoneNumber(cleanPhone)) {
            log.debug(`‚úÖ Found phone: ${cleanPhone}`);
            return cleanPhone;
          }
        }
      }
    }
    
    // Search page text for phone patterns
    const pageText = document.body.textContent;
    const phonePatterns = [
      /\(\d{3}\)\s*\d{3}[-\s]?\d{4}/g,  // (323) 610-0231
      /\d{3}[-\s]\d{3}[-\s]\d{4}/g,     // 323-610-0231 or 323 610 0231
      /\d{3}\.\d{3}\.\d{4}/g,           // 323.610.0231
      /\+1\s*\(\d{3}\)\s*\d{3}[-\s]?\d{4}/g, // +1 (323) 610-0231
      /\+1\s*\d{3}[-\s]\d{3}[-\s]\d{4}/g     // +1 323-610-0231
    ];
    
    for (const pattern of phonePatterns) {
      const matches = pageText.match(pattern);
      if (matches) {
        for (const match of matches) {
          const cleanPhone = this.cleanPhoneNumber(match);
          if (cleanPhone && this.isValidPhoneNumber(cleanPhone)) {
            log.debug(`‚úÖ Found phone in text: ${cleanPhone}`);
            return cleanPhone;
          }
        }
      }
    }
    
    log.debug('‚ùå No phone number found');
    return null;
  }

  extractOfficePhone() {
    const pageText = document.body.textContent;
    const officePhoneMatch = pageText.match(/(\(?\d{3}\)?[\s\-]?\d{3}[\s\-]?\d{4})\s+office/i);
    return officePhoneMatch ? officePhoneMatch[1] : null;
  }

  extractMobilePhone() {
    const pageText = document.body.textContent;
    const mobilePhoneMatch = pageText.match(/(\(?\d{3}\)?[\s\-]?\d{3}[\s\-]?\d{4})\s+mobile/i);
    return mobilePhoneMatch ? mobilePhoneMatch[1] : null;
  }

  extractCleanEmail() {
    log.debug('üìß Looking for email addresses...');
    
    // Enhanced email selectors
    const emailSelectors = [
      '[data-testid="email"]',
      '[data-testid="agent-email"]',
      '.email',
      '.agent-email',
      '.contact-email',
      'a[href^="mailto:"]',
      '[href*="mailto:"]',
      '.contact-info .email',
      '.agent-contact .email',
      '.email-address'
    ];
    
    // Try specific email elements first
    for (const selector of emailSelectors) {
      const elements = document.querySelectorAll(selector);
      for (const element of elements) {
        let email = null;
        
        // Check href attribute for mailto: links
        if (element.href && element.href.startsWith('mailto:')) {
          email = element.href.replace('mailto:', '').trim();
        } else {
          email = element.textContent?.trim();
        }
        
        log.debug(`üìß Testing email from ${selector}: "${email}"`);
        
        if (email && this.isValidEmail(email)) {
          log.debug(`‚úÖ Found email: ${email}`);
          return email;
        }
      }
    }
    
    // Search for mailto links in the page
    const mailtoLinks = document.querySelectorAll('a[href^="mailto:"]');
    for (const link of mailtoLinks) {
      const email = link.href.replace('mailto:', '').trim();
      log.debug(`üìß Testing mailto link: "${email}"`);
      
      if (this.isValidEmail(email)) {
        log.debug(`‚úÖ Found email from mailto: ${email}`);
        return email;
      }
    }
    
    // Search page text for email patterns
    const pageText = document.body.textContent;
    const emailPattern = /\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b/g;
    const emailMatches = pageText.match(emailPattern);
    
    if (emailMatches) {
      for (const email of emailMatches) {
        log.debug(`üìß Testing email from text: "${email}"`);
        
        if (this.isValidEmail(email) && !email.includes('realtor.com') && !email.includes('example.com')) {
          log.debug(`‚úÖ Found email in text: ${email}`);
          return email;
        }
      }
    }
    
    log.debug('‚ùå No email address found');
    return null;
  }

  extractWebsiteUrl() {
    log.debug('üåê Looking for website URLs...');
    
    // Enhanced website selectors
    const websiteSelectors = [
      '[data-testid="website"]',
      '[data-testid="agent-website"]',
      '.website',
      '.agent-website',
      '.personal-website',
      '.agent-url',
      'a[href*="website"]',
      'a[href*=".com"]:not([href*="realtor.com"])',
      'a[href*=".net"]',
      'a[href*=".org"]',
      '.contact-info a',
      '.agent-contact a'
    ];
    
    // Try specific website elements first
    for (const selector of websiteSelectors) {
      const elements = document.querySelectorAll(selector);
      for (const element of elements) {
        let url = null;
        
        // Check href attribute
        if (element.href) {
          url = element.href.trim();
        } else {
          url = element.textContent?.trim();
        }
        
        log.debug(`üåê Testing website from ${selector}: "${url}"`);
        
        if (url && this.isValidWebsiteUrl(url)) {
          const cleanUrl = this.cleanUrl(url);
          log.debug(`‚úÖ Found website: ${cleanUrl}`);
          return cleanUrl;
        }
      }
    }
    
    // Search for URLs in page text
    const pageText = document.body.textContent;
    const urlPattern = /https?:\/\/(?:www\.)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})*\.[a-zA-Z]{2,}/g;
    const urlMatches = pageText.match(urlPattern);
    
    if (urlMatches) {
      for (const url of urlMatches) {
        log.debug(`üåê Testing URL from text: "${url}"`);
        
        if (this.isValidWebsiteUrl(url)) {
          const cleanUrl = this.cleanUrl(url);
          log.debug(`‚úÖ Found website in text: ${cleanUrl}`);
          return cleanUrl;
        }
      }
    }
    
    log.debug('‚ùå No website URL found');
    return null;
  }

  isValidWebsiteUrl(url) {
    if (!url) return false;
    
    // Skip realtor.com URLs and other common invalid patterns
    const invalidPatterns = [
      'realtor.com',
      'realtordotcom',
      'facebook.com',
      'linkedin.com',
      'twitter.com',
      'instagram.com',
      'youtube.com',
      'google.com',
      'example.com',
      'mailto:',
      'tel:',
      '#'
    ];
    
    const urlLower = url.toLowerCase();
    
    for (const pattern of invalidPatterns) {
      if (urlLower.includes(pattern)) {
        return false;
      }
    }
    
    // Must be a valid URL format
    return /^https?:\/\//.test(url) || /^www\./.test(url) || /\.[a-zA-Z]{2,}/.test(url);
  }

  isValidEmail(email) {
    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    return emailRegex.test(email);
  }

  // ===== REVIEWS EXTRACTOR CLASS =====
  // Modularized reviews and recommendations extraction functionality
  // This will be moved to a separate file: modules/extractors/reviews-extractor.js
  
  extractReviews() {
    log.debug('üîç Delegating to ReviewsExtractor...');
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractReviews();
  }

  extractOverallRating(reviews) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractOverallRating(reviews);
  }

  extractReviewCount(reviews) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractReviewCount(reviews);
  }

  extractIndividualReviewsStructural(reviews) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractIndividualReviewsStructural(reviews);
  }

  extractReviewAuthor(element) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractReviewAuthor(element);
  }

  extractReviewRating(element) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractReviewRating(element);
  }

  extractReviewDate(element) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractReviewDate(element);
  }

  checkIfVerified(element) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.checkIfVerified(element);
  }

  extractCategoryRating(element, category) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractCategoryRating(element, category);
  }

  isValidReviewContent(text) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.isValidReviewContent(text);
  }

  extractReviewsByTextPatterns(reviews, pageText) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractReviewsByTextPatterns(reviews, pageText);
  }

  calculateTextSimilarity(text1, text2) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.calculateTextSimilarity(text1, text2);
  }

  extractModernRealtorReviews(reviews) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractModernRealtorReviews(reviews);
  }

  extractFullReviewFromContainer(containerText, expectedText) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractFullReviewFromContainer(containerText, expectedText);
  }

  isContaminatedText(text) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.isContaminatedText(text);
  }

  isRatingCategoryOnly(text) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.isRatingCategoryOnly(text);
  }

  extractReviewsGenericApproach(reviews) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractReviewsGenericApproach(reviews);
  }

  extractRecommendations(reviews) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractRecommendations(reviews);
  }

  extractAuthorFromText(text, element) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractAuthorFromText(text, element);
  }

  extractRecommendationsFromGenericPage(reviews) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractRecommendationsFromGenericPage(reviews);
  }

  isValidRecommendationText(text) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.isValidRecommendationText(text);
  }

  extractAuthorFromGenericElement(element) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractAuthorFromGenericElement(element);
  }

  extractDateFromGenericElement(element) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractDateFromGenericElement(element);
  }

  looksLikeName(text) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.looksLikeName(text);
  }

  extractReviewsByText(reviews) {
    if (!this.reviewsExtractor) {
      this.reviewsExtractor = new ReviewsExtractor();
    }
    return this.reviewsExtractor.extractReviewsByText(reviews);
  }

  // Original extractReviews method - now delegating to ReviewsExtractor
  _originalExtractReviews() {
    log.debug('üîç Looking for reviews with anti-scrambling techniques...');
    
    const reviews = {
      overall: {},
      individual: [],
      recommendations: []
    };

    // Method 1: Enhanced overall rating extraction with better priority
    this.extractOverallRating(reviews);
    
    // Method 2: Enhanced review count extraction
    this.extractReviewCount(reviews);
    
    // Method 3: Structure-based review extraction (more resilient)
    this.extractIndividualReviewsStructural(reviews);
    
    // Method 4: Text-pattern based extraction (fallback)
    if (reviews.individual.length === 0) {
      this.extractReviewsByTextPatterns(reviews, document.body.textContent);
    }
    
    // Method 5: Extract recommendations separately
    log.recommendation('üéØ Initiating recommendation extraction...');
    this.extractRecommendations(reviews);

    // Method 6: Generic page recommendation extraction (fallback for any website)
    if (reviews.recommendations.length < 10) {
      log.recommendation(`üéØ Only found ${reviews.recommendations.length} recommendations, trying generic extraction...`);
      this.extractRecommendationsFromGenericPage(reviews);
    } else {
      log.recommendation(`üéØ Found sufficient recommendations (${reviews.recommendations.length}/10), skipping generic extraction`);
    }

    // Limit to 5 reviews maximum
    if (reviews.individual.length > 5) {
      reviews.individual = reviews.individual.slice(0, 5);
      log.debug(`üîÑ Limited reviews to 5 (was ${reviews.individual.length + (reviews.individual.length - 5)})`);
    }

    // Limit to 10 recommendations maximum as requested
    if (reviews.recommendations.length > 10) {
      reviews.recommendations = reviews.recommendations.slice(0, 10);
      log.recommendation(`üîÑ Limited recommendations to 10 (was ${reviews.recommendations.length + (reviews.recommendations.length - 10)})`);
    }

    // Update count to reflect actual valid reviews found
    if (reviews.individual.length === 0) {
      reviews.overall.count = 0;
      log.debug(`üîç No valid reviews found, setting count to 0`);
    } else {
      // Only update count if we found actual reviews, otherwise keep original count for reference
      log.debug(`üîç Found ${reviews.individual.length} valid reviews`);
    }

    log.recommendation(`üèÜ Reviews extraction complete: ${reviews.individual.length} reviews, ${reviews.recommendations.length} recommendations`);
    
    // Print detailed recommendations to terminal
    if (reviews.recommendations.length > 0) {
      log.recommendation('\nüìã ===== EXTRACTED RECOMMENDATIONS =====');
      reviews.recommendations.forEach((rec, index) => {
        log.recommendation(`\nüéØ Recommendation ${index + 1}:`);
        log.recommendation(`   Author: ${rec.author}`);
        log.recommendation(`   Text: ${rec.text}`);
        if (rec.date) log.recommendation(`   Date: ${rec.date}`);
        if (rec.type) log.recommendation(`   Type: ${rec.type}`);
        log.recommendation(`   Source: ${rec.source}`);
        log.recommendation('   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
      });
      log.recommendation('üìã ===== END RECOMMENDATIONS =====\n');
    } else {
      log.recommendation('‚ùå No recommendations found on this page');
    }
    
    return reviews;
  }

  extractOverallRating(reviews) {
    log.debug('üåü Looking for overall rating with multiple methods...');
    
    // Method 1: Specific selectors (may be scrambled)
    const ratingSelectors = [
      '[data-testid="overall-rating"]',
      '.overall-rating',
      '.rating-value',
      '.star-rating',
      '.rating-number',
      '.review-rating',
      '.agent-rating',
      '[aria-label*="star rating"]',
      '[aria-label*="out of 5"]',
      '[class*="rating"]',
      '[class*="star"]'
    ];

    // Get overall rating with improved detection
    for (const selector of ratingSelectors) {
      const elements = document.querySelectorAll(selector);
      for (const element of elements) {
        const text = element.textContent?.trim();
        const ariaLabel = element.getAttribute('aria-label');
        
        // Check for explicit rating patterns
        const explicitRating = text?.match(/^(\d+(?:\.\d+)?)\s*(?:star|out of|\/5)?$/i);
        if (explicitRating && parseFloat(explicitRating[1]) >= 1 && parseFloat(explicitRating[1]) <= 5) {
          reviews.overall.rating = explicitRating[1];
          log.debug(`‚úÖ Found explicit rating: ${reviews.overall.rating} from selector: ${selector}`);
          break;
        }
        
        // Check aria-label for rating
        const ariaRating = ariaLabel?.match(/(\d+(?:\.\d+)?)\s*(?:star|out of 5)/i);
        if (ariaRating && parseFloat(ariaRating[1]) >= 1 && parseFloat(ariaRating[1]) <= 5) {
          reviews.overall.rating = ariaRating[1];
          log.debug(`‚úÖ Found aria-label rating: ${reviews.overall.rating}`);
          break;
        }
        
        // Count filled stars
        const filledStars = element.querySelectorAll('[class*="filled"], [class*="active"], .star-filled, [aria-label*="filled"]');
        if (filledStars.length > 0 && filledStars.length <= 5) {
          reviews.overall.rating = filledStars.length.toString();
          log.debug(`‚úÖ Found rating by counting ${filledStars.length} filled stars`);
          break;
        }
      }
      if (reviews.overall.rating) break;
    }

    // Enhanced review count extraction
    const reviewCountSelectors = [
      '[data-testid="review-count"]',
      '.review-count',
      '.total-reviews',
      '.reviews-total',
      '.review-summary',
      '[class*="review"][class*="count"]'
    ];

    for (const selector of reviewCountSelectors) {
      const element = document.querySelector(selector);
      if (element) {
        const text = element.textContent?.trim();
        const countMatch = text?.match(/(\d+)\s*(?:review|recommendation)/i);
        if (countMatch) {
          reviews.overall.count = countMatch[1];
          log.debug(`‚úÖ Found review count: ${reviews.overall.count}`);
          break;
        }
      }
    }

    // Search for review/recommendation text patterns in page content
    const pageText = document.body.textContent || '';
    
    // Look for overall review stats in text with more specific patterns
    if (!reviews.overall.rating) {
      // Look for "5 star", "4.8 out of 5", etc. with context
      const specificRatingPatterns = [
        /overall\s+rating\s*[:\-]?\s*(\d+(?:\.\d+)?)\s*(?:star|out of 5|\/5)/i,
        /agent\s+rating\s*[:\-]?\s*(\d+(?:\.\d+)?)\s*(?:star|out of 5|\/5)/i,
        /rated\s+(\d+(?:\.\d+)?)\s*(?:star|out of 5|\/5)/i,
        /(\d+(?:\.\d+)?)\s*star\s+(?:rating|agent|overall)/i,
        /(\d+(?:\.\d+)?)\s*out\s+of\s+5\s+stars?/i
      ];
      
      for (const pattern of specificRatingPatterns) {
        const match = pageText.match(pattern);
        if (match && parseFloat(match[1]) >= 1 && parseFloat(match[1]) <= 5) {
          reviews.overall.rating = match[1];
          log.debug(`‚úÖ Found contextual rating in text: ${reviews.overall.rating}`);
          break;
        }
      }
    }

    if (!reviews.overall.count) {
      const countTextMatch = pageText.match(/(\d+)\s*(?:reviews?|recommendations?)/i);
      if (countTextMatch) {
        reviews.overall.count = countTextMatch[1];
        log.debug(`‚úÖ Found count in text: ${reviews.overall.count}`);
      }
    }

    // Enhanced individual reviews extraction
    const reviewSelectors = [
      '[data-testid*="review"]',
      '.review-item',
      '.individual-review',
      '.review',
      '.customer-review',
      '.testimonial',
      '[class*="review"][class*="item"]',
      '[class*="testimonial"]'
    ];

    let reviewElements = [];
    reviewSelectors.forEach(selector => {
      const elements = document.querySelectorAll(selector);
      elements.forEach(el => {
        if (!reviewElements.includes(el)) {
          reviewElements.push(el);
        }
      });
    });

    log.debug(`üìù Found ${reviewElements.length} potential review elements`);

    reviewElements.forEach((reviewEl, index) => {
      const reviewText = this.getTextContent([
        '.review-text', 
        '.review-content', 
        '.review-body',
        '.testimonial-text',
        '.content',
        'p',
        'div'
      ], reviewEl);
      
      if (reviewText && this.isValidReviewContent(reviewText)) { // Use validation instead of just length check
        const review = {
          id: index + 1,
          rating: this.extractReviewRating(reviewEl),
          text: this.cleanTextForCSV(reviewText),
          author: this.getTextContent([
            '.reviewer-name', 
            '.review-author', 
            '.customer-name',
            '.author',
            '.name',
            'strong',
            'b'
          ], reviewEl),
          date: this.extractReviewDate(reviewEl),
          location: this.getTextContent([
            '.location',
            '.reviewer-location'
          ], reviewEl),
          verified: this.checkIfVerified(reviewEl),
          type: this.getTextContent([
            '.review-type',
            '.transaction-type'
          ], reviewEl),
          propertyType: this.getTextContent([
            '.property-type'
          ], reviewEl),
          categories: {
            responsiveness: this.extractCategoryRating(reviewEl, 'responsiveness'),
            negotiation: this.extractCategoryRating(reviewEl, 'negotiation'),
            professionalism: this.extractCategoryRating(reviewEl, 'professionalism'),
            marketExpertise: this.extractCategoryRating(reviewEl, 'market')
          }
        };
        
        reviews.individual.push(review);
        log.debug(`üìù Extracted review ${index + 1}: "${review.text.substring(0, 50)}..."`);
      }
    });

    // Extract reviews and recommendations from text patterns
    this.extractReviewsByTextPatterns(reviews, pageText);

    // Extract recommendations separately
    this.extractRecommendations(reviews);

    // Limit to 5 reviews maximum
    if (reviews.individual.length > 5) {
      reviews.individual = reviews.individual.slice(0, 5);
      log.debug(`üîÑ Limited reviews to 5 (was ${reviews.individual.length + (reviews.individual.length - 5)})`);
    }

    log.recommendation(`üèÜ Reviews extraction complete: ${reviews.individual.length} reviews, ${reviews.recommendations.length} recommendations`);
    
    return reviews;
  }

  extractReviewCount(reviews) {
    log.debug('üìä Looking for review count...');
    
    // Method 1: Specific selectors
    const countSelectors = [
      '[data-testid="review-count"]',
      '.review-count',
      '.reviews-count',
      '[class*="count"]'
    ];

    for (const selector of countSelectors) {
      const element = document.querySelector(selector);
      if (element) {
        const countMatch = element.textContent?.match(/(\d+)\s*reviews?/i);
        if (countMatch) {
          reviews.overall.count = countMatch[1];
          log.debug(`‚úÖ Found review count: ${reviews.overall.count}`);
          return;
        }
      }
    }

    // Method 2: Text pattern search
    const countPattern = /(\d+)\s*(?:reviews?|ratings?)/i;
    const pageText = document.body.textContent;
    const countTextMatch = pageText.match(countPattern);
    if (countTextMatch) {
      reviews.overall.count = countTextMatch[1];
      log.debug(`‚úÖ Found count in text: ${reviews.overall.count}`);
    }
  }

  extractIndividualReviewsStructural(reviews) {
    log.debug('üìù Looking for individual reviews with structural approach...');
    
    // Look for review-like structures rather than specific classes
    const potentialReviewElements = [];
    
    // Find elements with review-like text patterns
    const allElements = document.querySelectorAll('div, article, section, li');
    
    allElements.forEach(el => {
      const text = el.textContent?.trim();
      if (text && text.length > 50 && text.length < 2000) {
        // Check if it contains review-like phrases
        const reviewIndicators = [
          'helped me', 'helped us', 'worked with', 'excellent', 'recommend',
          'professional', 'knowledgeable', 'responsive', 'great experience',
          'bought', 'sold', 'purchase', 'sale', 'realtor', 'agent'
        ];
        
        const indicatorCount = reviewIndicators.filter(indicator => 
          text.toLowerCase().includes(indicator)
        ).length;
        
        if (indicatorCount >= 2) {
          potentialReviewElements.push(el);
        }
      }
    });

    log.debug(`üìù Found ${potentialReviewElements.length} potential review elements`);

    potentialReviewElements.slice(0, 5).forEach((reviewEl, index) => {
      const reviewText = reviewEl.textContent?.trim();
      
      if (reviewText && this.isValidReviewContent(reviewText)) {
        const review = {
          id: index + 1,
          rating: this.extractReviewRating(reviewEl),
          text: this.cleanTextForCSV(reviewText),
          author: this.extractReviewAuthor(reviewEl),
          date: this.extractReviewDate(reviewEl),
          location: null,
          verified: this.checkIfVerified(reviewEl),
          type: null
        };
        
        reviews.individual.push(review);
        log.debug(`üìù Extracted structural review ${index + 1}: "${review.text.substring(0, 50)}..."`);
      }
    });
  }

  extractReviewAuthor(element) {
    // Look for author in nearby elements or within the review element
    const authorPatterns = [
      'by ', 'from ', '- ', 'reviewed by ', 'customer: ', 'client: '
    ];
    
    const text = element.textContent || '';
    
    for (const pattern of authorPatterns) {
      const regex = new RegExp(pattern + '([A-Z][a-z]+(?: [A-Z][a-z]*)*)', 'i');
      const match = text.match(regex);
      if (match) {
        return match[1];
      }
    }
    
    // Look for name patterns at the end of the text
    // Simplified regex to properly handle names like McDowell, O'Brien, etc.
    const nameMatch = text.match(/([A-Z][a-z]+(?:[A-Z][a-z]+|'[A-Z][a-z]+)?\s+[A-Z][a-z]+(?:[A-Z][a-z]+|'[A-Z][a-z]+)?(?:\s+[A-Z][a-z]+)?)\s*$/);
    if (nameMatch) {

      return nameMatch[1];
    }
    
    return null;
  }

  extractReviewRating(element) {
    // Try multiple approaches to find rating within review element
    const ratingSelectors = [
      '.rating', 
      '.review-rating', 
      '.stars', 
      '.star-rating',
      '.rating-value',
      '[aria-label*="star"]',
      '[class*="rating"]',
      '[class*="star"]'
    ];
    
    for (const selector of ratingSelectors) {
      const ratingEl = element.querySelector(selector);
      if (ratingEl) {
        const text = ratingEl.textContent?.trim();
        const ariaLabel = ratingEl.getAttribute('aria-label');
        
        // Check text content for explicit rating
        const textMatch = text?.match(/(\d+(?:\.\d+)?)/);
        if (textMatch && parseFloat(textMatch[1]) >= 1 && parseFloat(textMatch[1]) <= 5) {
          log.debug(`‚úÖ Found review rating in text: ${textMatch[1]}`);
          return textMatch[1];
        }
        
        // Check aria-label
        const ariaMatch = ariaLabel?.match(/(\d+(?:\.\d+)?)\s*(?:star|out of)/i);
        if (ariaMatch && parseFloat(ariaMatch[1]) >= 1 && parseFloat(ariaMatch[1]) <= 5) {
          log.debug(`‚úÖ Found review rating in aria-label: ${ariaMatch[1]}`);
          return ariaMatch[1];
        }
        
        // Count filled stars with limit to prevent loops
        const filledStars = ratingEl.querySelectorAll('[class*="filled"], [class*="active"], .star-filled');
        if (filledStars.length > 0 && filledStars.length <= 5) {
          log.debug(`‚úÖ Found review rating by counting stars: ${filledStars.length}`);
          return filledStars.length.toString();
        }
        
        // Count total star elements if they seem to represent a rating
        const allStars = ratingEl.querySelectorAll('[class*="star"], svg');
        if (allStars.length > 0 && allStars.length <= 5) {
          log.debug(`‚úÖ Found review rating from total stars: ${allStars.length}`);
          return allStars.length.toString();
        }
      }
    }
    
    // Look for rating in the review text itself
    const reviewText = element.textContent || '';
    const textRatingPatterns = [
      /overall\s+rating\s*\((\d+)\)/i,
      /rating\s*[:\-]?\s*(\d+(?:\.\d+)?)\s*(?:star|out of 5)/i,
      /(\d+(?:\.\d+)?)\s*star\s+rating/i,
      /rated\s+(\d+(?:\.\d+)?)/i,
      /(\d+(?:\.\d+)?)\s*\/\s*5/i,
      /(\d+(?:\.\d+)?)\s*out\s+of\s+5/i
    ];
    
    for (const pattern of textRatingPatterns) {
      const match = reviewText.match(pattern);
      if (match && parseFloat(match[1]) >= 1 && parseFloat(match[1]) <= 5) {
        log.debug(`‚úÖ Found review rating in text pattern: ${match[1]}`);
        return match[1];
      }
    }
    
    // If no individual rating found, check if this looks like a positive review
    // and use a default high rating for positive reviews
    if (reviewText.length > 50) {
      const positiveWords = ['excellent', 'amazing', 'great', 'fantastic', 'outstanding', 'wonderful', 'highly recommend', 'recommend', 'professional', 'helpful'];
      const negativeWords = ['terrible', 'awful', 'bad', 'worst', 'horrible', 'disappointing'];
      
      const lowerText = reviewText.toLowerCase();
      const positiveCount = positiveWords.filter(word => lowerText.includes(word)).length;
      const negativeCount = negativeWords.filter(word => lowerText.includes(word)).length;
      
      if (positiveCount > negativeCount && positiveCount > 0) {
        log.debug(`‚úÖ Inferred high rating from positive review sentiment`);
        return '5'; // Default to 5 stars for clearly positive reviews
      } else if (negativeCount > 0) {
        log.debug(`‚úÖ Inferred low rating from negative review sentiment`);
        return '2'; // Default to 2 stars for negative reviews
      }
    }
    
    log.debug(`‚ùå No rating found for review element`);
    return null;
  }

  extractReviewDate(element) {
    const dateSelectors = ['.review-date', '.date', '.timestamp', 'time'];
    for (const selector of dateSelectors) {
      const dateEl = element.querySelector(selector);
      if (dateEl) {
        const text = dateEl.textContent?.trim();
        const datetime = dateEl.getAttribute('datetime');
        
        // Return datetime attribute if available
        if (datetime) return datetime;
        
        // Look for date patterns in text
        const dateMatch = text?.match(/(\d{1,2}\/\d{1,2}\/\d{4}|\d{4}-\d{2}-\d{2}|\w+ \d{1,2}, \d{4}|\d+ \w+ ago)/i);
        if (dateMatch) return dateMatch[1];
      }
    }
    return null;
  }

  checkIfVerified(element) {
    const verifiedSelectors = ['.verified', '.verified-badge', '[class*="verified"]'];
    for (const selector of verifiedSelectors) {
      if (element.querySelector(selector)) return true;
    }
    
    const text = element.textContent?.toLowerCase() || '';
    return text.includes('verified') || text.includes('confirmed');
  }

  extractCategoryRating(element, category) {
    const categoryEl = element.querySelector(`[class*="${category}"], [data-category="${category}"]`);
    if (categoryEl) {
      const text = categoryEl.textContent?.trim();
      const match = text?.match(/(\d+(?:\.\d+)?)/);
      return match ? match[1] : null;
    }
    return null;
  }

  // Helper function to validate if text is actually a review/recommendation or just form text
  isValidReviewContent(text) {
    if (!text || text.length < 20) return false;
    
    // CRITICAL: Block navigation/UI elements that are contaminating testimonials
    const navigationPatterns = [
      /rating.*high.*low/i,
      /buyer.*reviews.*seller.*reviews/i, 
      /add.*testimonial/i,
      /overall.*rating.*add/i,
      /newest.*first.*rating/i,
      /\d+\.\d+.*responsiveness.*market.*expertise/i,
      /testimonials.*\(\d+\).*add/i,
      /reviews.*buyer.*reviews/i,
      /sort.*rating.*high/i,
      /filter.*newest.*first/i,
      /all.*reviews.*buyer.*seller/i,
      /responsiveness.*market.*expertise.*negotiation/i,
      // CRITICAL: Block all rating category content - these are NOT reviews
      /^(professionalism|responsiveness|market expertise|negotiation skills)\s*&?\s*communication\.?\s*$/i,
      /^\s*(professionalism|responsiveness|market|negotiation)\s*&?\s*communication\.?\s*$/i,
      /^(professionalism|responsiveness|market expertise|negotiation skills)\.?\s*$/i,
      /^professionalism\s*&\s*communication$/i,
      /^responsiveness$/i,
      /^market\s*expertise$/i,
      /^negotiation\s*skills$/i,
      // EXPANDED: Block any text that's just rating categories
      /^(professionalism|responsiveness|market|negotiation|communication)$/i,
      /^(overall\s*rating|buyer\s*agent|seller\s*agent)$/i,
      // Block standalone rating scores
      /^\d+\.\d+\s*$/,
      /^\d+\.\d+\s*out\s*of\s*\d+/i,
      // CRITICAL: Block review prompt text - these are UI prompts, not actual reviews
      /Ratings and reviews.*Did .* help you/i,
      /Did .* help you with your property/i,
      /Did .* help you.*property/i
    ];

    // Check for navigation patterns first (PRIORITY CHECK)
    for (const pattern of navigationPatterns) {
      if (pattern.test(text)) {
        log.debug(`‚ùå Rejected navigation content: "${text.substring(0, 50)}..."`);
        return false;
      }
    }

    // SPECIAL CHECK: Detect and block review prompt patterns that might slip through
    if (text.toLowerCase().includes('ratings and reviews') && text.toLowerCase().includes('did') && text.toLowerCase().includes('help you')) {

      log.debug(`‚ùå Blocked review prompt: "${text}"`);
      return false;
    }
    
    // CRITICAL: Exclude agent bio content from being treated as reviews/recommendations
    const isBioContent = (
      text.includes('Hello! My name is') ||
      text.includes('I am the Broker/Owner of') ||
      text.includes('Comfort Real Estate Services') ||
      text.includes('I have lived in the gorgeous coastal region') ||
      text.includes('After obtaining my broker license') ||
      text.includes('we closed nearly $10 million') ||
      text.includes('B.J. Ward') ||
      text.startsWith('Hello!') ||
      // NEW: Block the specific bio text that's been showing up
      text.includes('In 2009, I was selected as one of REALTOR¬Æ Magazine\'s 30 under 30') ||
      text.includes('This was a tremendous honor as it attest to the success') ||
      text.includes('The magazine chooses just 30 agents, owners or managers under the age of 30') ||
      text.includes('30 under 30 across the nation to feature for their achievements') ||
      text.includes('REALTOR¬Æ Magazine\'s 30 under 30') ||
      text.includes('30 under 30') && text.includes('achievements in the real estate field') ||
      // Bio patterns
      (text.includes('real estate') && text.includes('experience') && text.includes('years') && text.length > 300) ||
      (text.includes('broker') && text.includes('licensed') && text.length > 200) ||
      // Achievement/award content (not customer reviews)
      (text.includes('selected') && text.includes('magazine') && text.includes('honor')) ||
      (text.includes('award') && text.includes('achievement') && text.length > 200)
    );
    
    if (isBioContent) {

      log.debug(`‚ùå Rejected bio content being treated as review: "${text.substring(0, 100)}..."`);
      return false;
    }
    
    // Filter out common form prompts and invalid content
    const invalidPatterns = [
      /No reviews provided yet/i,
      /No recommendations provided yet/i,
      /Did this agent help with your home/i,
      /Share your experience with this agent/i,
      /Write.*first recommendation/i,
      /Connect with.*at.*Realty/i,
      /Full name.*Email.*Phone.*Message/i,
      /Recaptcha Response/i,
      /Send email/i,
      /By proceeding, you consent to receive/i,
      /calls and texts at the number you provided/i,
      /marketing by autodialer/i,
      /realtor\.com.*about your inquiry/i,
      /not as a condition of any purchase/i,
      /More\.\.\./i,
      /Contact details/i,
      /mobile.*Kristin L\. Arledge/i,
      // CRITICAL: Block the specific "Did [Agent Name] help you" prompts that are not reviews
      /Ratings and reviews.*Did .* help you with your property\?/i,
      /Did .* help you with your property\?/i,
      /Ratings and reviews.*Did .* help you/i,
      /Did .* help you.*property/i
    ];
    
    // Check if text matches any invalid patterns
    for (const pattern of invalidPatterns) {
      if (pattern.test(text)) {
        log.debug(`‚ùå Rejected invalid content: "${text.substring(0, 50)}..."`);
        return false;
      }
    }
    
    // Additional checks for form-like content AND NAVIGATION
    if (text.includes('EmailPhoneMessage') || 
        text.includes('Recaptcha') || 
        text.includes('Send email') ||
        text.includes('calls and texts') ||
        text.includes('autodialer') ||
        text.includes('rating (high to low)') ||     // Block rating filters
        text.includes('buyer reviews seller') ||     // Block review type filters  
        text.includes('add a testimonial') ||        // Block UI buttons
        text.includes('overall rating') ||           // Block rating widgets
        text.length < 30 ||                          // Too short to be meaningful
        text.length > 1200) {                        // Increased limit for full testimonials
      log.debug(`‚ùå Rejected form/navigation content: "${text.substring(0, 50)}..."`);
      return false;
    }
    
    return true;
  }

  extractReviewsByTextPatterns(reviews, pageText) {
    // Pattern for verified reviews
    const verifiedPattern = /Verified (?:review|buyer|seller)\s*[:\-]?\s*([^]+?)(?=\n\n|\r\n\r\n|Verified|$)/gi;
    let match;
    
    while ((match = verifiedPattern.exec(pageText)) !== null) {
      const text = match[1]?.trim();
      if (text && this.isValidReviewContent(text) && text.length < 1000) {
        reviews.individual.push({
          text: this.cleanTextForCSV(text),
          verified: true,
          source: 'text_pattern'
        });
      }
    }

    // IMPROVED: Look for actual testimonial/recommendation sections in the page text
    const maxRecommendations = 10;
    let recommendationCount = reviews.recommendations.length;
    
    // Find large blocks of text that look like testimonials (more than 50 characters)
    const textBlocks = pageText.split(/\n\n+|\r\n\r\n+/).filter(block => 
      block.trim().length > 50 && 
      block.trim().length < 1000 &&
      this.isValidReviewContent(block.trim())
    );
    
    log.recommendation(`üîç Found ${textBlocks.length} potential text blocks for recommendations`);
    
    textBlocks.forEach((block, index) => {
      if (recommendationCount >= maxRecommendations) return;
      
      const cleanBlock = block.trim();
      
      // Try to extract author from the text block
      let author = 'Anonymous';
      let text = cleanBlock;
      
      // Look for author patterns at the end of the text
      const authorEndPatterns = [
        /(.+?)\s*[-‚Äì‚Äî]\s*([A-Z][a-z]+ [A-Z][a-z]*(?:\s[A-Z]\.?)?)\s*$/,
        /(.+?)\s*[-‚Äì‚Äî]\s*([A-Z][a-z]+ [A-Z]\.)?\s*$/,
        /(.+?)\s*\-\s*([A-Z][a-z]+ [A-Z][a-z]*)\s*$/
      ];
      
      // Look for author patterns at the beginning of the text
      const authorStartPatterns = [
        /^([A-Z][a-z]+ [A-Z][a-z]*(?:\s[A-Z]\.?)?)\s*[-‚Äì‚Äî:]\s*(.+)$/,
        /^([A-Z][a-z]+ [A-Z]\.)?\s*[-‚Äì‚Äî:]\s*(.+)$/
      ];
      
      // Try end patterns first
      for (const pattern of authorEndPatterns) {
        const match = cleanBlock.match(pattern);
        if (match && match[2]) {
          text = match[1].trim();
          author = match[2].trim();
          break;
        }
      }
      
      // If no author found at end, try beginning
      if (author === 'Anonymous') {
        for (const pattern of authorStartPatterns) {
          const match = cleanBlock.match(pattern);
          if (match && match[1]) {
            author = match[1].trim();
            text = match[2].trim();
            break;
          }
        }
      }
      
      // Final validation
      if (text && text.length > 30 && this.isValidReviewContent(text)) {
        const recommendation = {
          author: author,
          text: this.cleanTextForCSV(text),
          source: `text_pattern_${index + 1}`
        };
        
        // Check for duplicates
        const isDuplicate = reviews.recommendations.some(existing => 
          this.calculateTextSimilarity(existing.text, recommendation.text) > 0.8
        );
        
        if (!isDuplicate) {
          reviews.recommendations.push(recommendation);
          recommendationCount++;
          log.recommendation(`üéØ Text pattern recommendation ${recommendationCount}: "${author}" - "${text.substring(0, 50)}..."`);
        }
      }
    });
    
    log.recommendation(`üéØ Total recommendations after text patterns: ${recommendationCount}/${maxRecommendations}`);
  }

  // Helper method to calculate text similarity (simple approach)
  calculateTextSimilarity(text1, text2) {
    if (!text1 || !text2) return 0;
    
    const words1 = text1.toLowerCase().split(/\s+/);
    const words2 = text2.toLowerCase().split(/\s+/);
    
    const set1 = new Set(words1);
    const set2 = new Set(words2);
    
    const intersection = new Set([...set1].filter(x => set2.has(x)));
    const union = new Set([...set1, ...set2]);
    
    return intersection.size / union.size;
  }

  // NEW: Extract modern Realtor.com verified review format
  extractModernRealtorReviews(reviews) {
    log.recommendation('üéØ COMPLETELY NEW APPROACH - Direct element analysis...');
    
    // STEP 1: Find all elements that contain expected reviewer names
    const expectedReviewers = [
      { name: 'Belinda Gillis', expectedText: 'We\'ve worked with BJ on three real estate transactions' },
      { name: 'Robert Bruce', expectedText: 'We were referred to B.J. by our parents' },
      { name: 'Felicia', expectedText: 'BJ & his staff consistently provide exceptional service' },
      { name: 'Jen', expectedText: 'I had the pleasure of working with BJ Ward' },
      { name: 'Josh', expectedText: 'B.J. did a fantastic job guiding me through' },
      { name: 'James', expectedText: 'BJ helped us sell our house back in early 2021' },
      { name: '29 Eleven', expectedText: 'Comfort Realty and BJ Ward walked me through my first home purchase' }
    ];
    
    let foundReviews = 0;
    
    expectedReviewers.forEach(reviewer => {
      log.recommendation(`üîç Searching for reviewer: ${reviewer.name}`);
      
      // First check: does the page even contain the expected review text?
      const pageText = document.body.textContent;
      if (!pageText.includes(reviewer.expectedText)) {
        log.recommendation(`‚ùå SKIPPING ${reviewer.name} - expected review text not found on page`);
        return; // Skip this reviewer entirely
      }
      
      // Find all elements containing the reviewer name
      const nameElements = Array.from(document.querySelectorAll('*')).filter(el => 
        el.textContent && el.textContent.includes(reviewer.name)
      );
      
      log.recommendation(`  Found ${nameElements.length} elements containing "${reviewer.name}"`);
      
      // For each element, check if it or its container has the expected review text
      nameElements.forEach((nameEl, index) => {
        if (foundReviews >= 10) return; // Limit total reviews
        
        const containers = [nameEl];
        
        // Add parent containers to search
        let parent = nameEl.parentElement;
        for (let i = 0; i < 5 && parent; i++) {
          containers.push(parent);
          parent = parent.parentElement;
        }
        
        // Check each container for the expected review text
        containers.forEach(container => {
          const containerText = container.textContent;
          
          if (containerText.includes(reviewer.expectedText)) {
            log.recommendation(`üéØ FOUND CORRECT CONTAINER for ${reviewer.name}!`);
            log.recommendation(`  Container: ${container.tagName}.${container.className}`);
            log.recommendation(`  Text length: ${containerText.length}`);
            
            // Extract the full review text
            const fullReviewText = this.extractFullReviewFromContainer(containerText, reviewer.expectedText);
            
            if (fullReviewText && fullReviewText.length > 50) {
              // Check if we already have this review
              const isDuplicate = reviews.recommendations.some(existing => 
                existing.author === reviewer.name || 
                this.calculateTextSimilarity(existing.text, fullReviewText) > 0.8
              );
              
              if (!isDuplicate) {
                reviews.recommendations.push({
                  text: this.cleanTextForCSV(fullReviewText),
                  author: reviewer.name,
                  source: 'direct_search'
                });
                foundReviews++;
                log.recommendation(`‚úÖ Added review for ${reviewer.name}: "${fullReviewText.substring(0, 100)}..."`);
                return; // Found it, no need to check other containers
              }
            }
          } else {
            // Check if this container has rating categories only
            const hasOnlyRatingCategories = containerText.includes('Professionalism & communication') &&
                                          !containerText.includes(reviewer.expectedText);
            
            if (hasOnlyRatingCategories) {
              log.recommendation(`‚ùå SKIPPING ${reviewer.name} - container has only rating categories, not actual review text`);
              return;
            }
          }
        });
      });
    });
    
    // STEP 2: If we didn't find enough reviews, fall back to generic extraction
    if (foundReviews < 3) {
      log.recommendation(`üîç Only found ${foundReviews} specific reviews, trying generic approach...`);
      this.extractReviewsGenericApproach(reviews);
    }
    
    // STEP 3: POST-EXTRACTION CLEANUP - Remove any rating category reviews
    if (reviews && reviews.recommendations && Array.isArray(reviews.recommendations)) {
      const beforeCleanup = reviews.recommendations.length;
      reviews.recommendations = reviews.recommendations.filter(rec => {
        const isRatingCategory = this.isRatingCategoryOnly(rec.text);
        if (isRatingCategory) {
          log.recommendation(`üö´ POST-CLEANUP: Removing rating category review - "${rec.text}" by ${rec.author}`);
          return false;
        }
        return true;
      });
      
      const afterCleanup = reviews.recommendations.length;
      if (beforeCleanup !== afterCleanup) {
        log.recommendation(`üßπ CLEANUP: Removed ${beforeCleanup - afterCleanup} rating category reviews`);
      }
      
      log.recommendation(`üéØ Total extracted: ${reviews.recommendations.length} recommendations`);
    } else {

      if (!reviews) reviews = {};
      if (!reviews.recommendations) reviews.recommendations = [];
      log.recommendation(`üéØ Total extracted: 0 recommendations (reviews object was invalid)`);
    }
  }

  // Extract the full review text from a container that contains the expected text
  extractFullReviewFromContainer(containerText, expectedText) {
    try {
      // Find where the expected text starts
      const expectedIndex = containerText.indexOf(expectedText);
      if (expectedIndex === -1) return null;
      
      // Get text starting from the expected text
      let reviewText = containerText.substring(expectedIndex);
      
      // Clean up the text by removing common suffixes/prefixes
      reviewText = reviewText
        .split('Sourced by')[0]  // Remove "Sourced by" and everything after
        .split('Verified review')[0]  // Remove verification info if it appears
        .split('itemReviewed')[0]  // Remove JSON schema markup
        .split('@type')[0]  // Remove schema.org markup
        .split('RealEstateAgent')[0]  // Remove schema markup
        .replace(/\d+\.\d+\s*(Responsiveness|Market expertise|Negotiation skills|Professionalism & communication)/g, '') // Remove ratings
        .replace(/^\d+\.\d+\s*$/gm, '') // Remove standalone numbers
        .replace(/^(Responsiveness|Market expertise|Negotiation skills|Professionalism & communication)\s*$/gm, '') // Remove category names
        .replace(/,\s*itemReviewed\s*:\s*{[^}]*}/g, '') // Remove JSON objects
        .replace(/https?:\/\/[^\s,]*/g, '') // Remove URLs
        .replace(/\s+/g, ' ') // Normalize whitespace
        .trim();
      
      // CRITICAL: Reject if the result is just rating categories
      if (this.isRatingCategoryOnly(reviewText)) {
        log.recommendation(`‚ùå Rejected rating category text: "${reviewText}"`);
        return null;
      }
      
      // Find the end of the review (usually a sentence ending)
      const sentences = reviewText.split(/[.!?]+/);
      let cleanReview = '';
      
      for (let i = 0; i < sentences.length; i++) {
        const sentence = sentences[i].trim();
        if (sentence.length > 10 && 
            this.isValidReviewContent(sentence) && 
            !this.isRatingCategoryOnly(sentence) &&
            !sentence.includes('itemReviewed') &&
            !sentence.includes('@type') &&
            !sentence.includes('RealEstateAgent')) {
          cleanReview += sentence;
          if (i < sentences.length - 1) cleanReview += '. ';
          
          // Stop if we have a substantial review (>100 chars) and hit a natural break
          if (cleanReview.length > 100 && sentence.length > 20) {
            break;
          }
        }
      }
      
      const finalText = cleanReview.trim();
      
      // Final check: make sure we don't return rating categories or contaminated text
      if (this.isRatingCategoryOnly(finalText) || this.isContaminatedText(finalText)) {
        log.recommendation(`‚ùå Final rejection - rating category or contaminated: "${finalText}"`);
        return null;
      }
      
      return finalText;
      
    } catch (error) {
      log.recommendation(`‚ùå Error extracting review text:`, error);
      return null;
    }
  }

  // NEW: Check for contaminated text (JSON, markup, etc.)
  isContaminatedText(text) {
    if (!text) return true;
    
    const contaminationPatterns = [
      /itemReviewed/i,
      /@type/i,
      /RealEstateAgent/i,
      /schema\.org/i,
      /application\/ld\+json/i,
      /{[^}]*"@type"[^}]*}/i,
      /https?:\/\/ap\./i,
      /\bimage\s*:\s*https/i
    ];
    
    const isContaminated = contaminationPatterns.some(pattern => pattern.test(text));
    
    if (isContaminated) {
      log.recommendation(`üö´ BLOCKED contaminated text: "${text.substring(0, 50)}..."`);
      return true;
    }
    
    return false;
  }

  // NEW: Check if text is just rating categories (should be rejected)
  isRatingCategoryOnly(text) {
    if (!text || text.length < 3) return true;
    
    const ratingOnlyPatterns = [
      /^(professionalism|responsiveness|market\s*expertise|negotiation\s*skills)\s*&?\s*communication\.?\s*$/i,
      /^\s*(professionalism|responsiveness|market|negotiation)\s*&?\s*communication\.?\s*$/i,
      /^(professionalism|responsiveness|market\s*expertise|negotiation\s*skills)\.?\s*$/i,
      /^professionalism\s*&\s*communication$/i,
      /^(responsiveness|market\s*expertise|negotiation\s*skills|overall\s*rating)$/i,
      /^\d+\.\d+\s*$/,
      /^\d+\.\d+\s*out\s*of\s*\d+/i,
      /^(buyer\s*agent|seller\s*agent|overall\s*rating)$/i
    ];
    
    // Check if text matches any rating-only pattern
    const isRatingOnly = ratingOnlyPatterns.some(pattern => pattern.test(text.trim()));
    
    if (isRatingOnly) {
      log.recommendation(`üö´ BLOCKED rating category: "${text}"`);
      return true;
    }
    
    // Additional check: if text is very short and contains rating keywords
    if (text.length < 50 && text.match(/(professionalism|responsiveness|market|negotiation|communication)/i)) {
      log.recommendation(`üö´ BLOCKED short rating text: "${text}"`);
      return true;
    }
    
    return false;
  }

  // Generic approach for finding additional reviews
  extractReviewsGenericApproach(reviews) {
    log.recommendation('üîç Using generic extraction approach...');
    
    // Look for common review patterns in the page text
    const pageText = document.body.textContent;
    
    // Pattern for reviews with author attribution
    const reviewPatterns = [
      /([^.!?]{50,500}[.!?])\s*[-‚Äì‚Äî]\s*([A-Z][a-z]+(?:\s[A-Z][a-z]*)*)\s*$/gm,
      /"([^"]{50,500})"\s*[-‚Äì‚Äî]\s*([A-Z][a-z]+(?:\s[A-Z][a-z]*)*)/g
    ];
    
    reviewPatterns.forEach((pattern, patternIndex) => {
      let match;
      while ((match = pattern.exec(pageText)) !== null && reviews.recommendations.length < 10) {
        const [fullMatch, reviewText, author] = match;
        
        // CRITICAL: Check if this is just rating categories
        if (this.isRatingCategoryOnly(reviewText)) {
          log.recommendation(`üö´ SKIPPED rating category in generic extraction: "${reviewText}" - ${author}`);
          continue;
        }
        
        if (this.isValidReviewContent(reviewText) && this.looksLikeName(author)) {
          // Check for duplicates
          const isDuplicate = reviews.recommendations.some(existing => 
            existing.author === author || 
            this.calculateTextSimilarity(existing.text, reviewText) > 0.8
          );
          
          if (!isDuplicate) {
            reviews.recommendations.push({
              text: this.cleanTextForCSV(reviewText.trim()),
              author: author,
              source: `generic_pattern_${patternIndex + 1}`
            });
            log.recommendation(`‚úÖ Generic extraction: "${author}" - "${reviewText.substring(0, 50)}..."`);
          }
        }
      }
    });
  }

  extractRecommendations(reviews) {
    log.recommendation('üîç Starting extractRecommendations method...');
    
    // FIRST: Try modern Realtor.com verified review format extraction
    this.extractModernRealtorReviews(reviews);
    
    // Enhanced recommendation selectors to catch more patterns
    const recommendationSelectors = [
      '.recommendation',
      '.testimonial',
      '.review-recommendation',
      '.client-testimonial',
      '.agent-testimonial',
      '[data-testid*="recommendation"]',
      '[data-testid*="testimonial"]',
      '[class*="recommendation"]',
      '[class*="testimonial"]',
      '[class*="review"][class*="positive"]',
      '.client-review',
      '.customer-feedback',
      '.endorsement',
      '.praise',
      '.commendation',
      // Add more generic selectors for broader coverage
      '.quote',
      '.feedback',
      '.comment',
      'blockquote',
      '[class*="quote"]',
      '[class*="feedback"]',
      '[class*="comment"]',
      '[class*="story"]',
      '[class*="experience"]',
      // Look for review-like containers
      '[class*="review"]',
      '[id*="review"]',
      '[id*="testimonial"]',
      '[id*="recommendation"]'
    ];

    let recommendationElements = [];
    recommendationSelectors.forEach(selector => {
      const elements = document.querySelectorAll(selector);
      elements.forEach(el => {
        if (!recommendationElements.includes(el)) {
          recommendationElements.push(el);
        }
      });
    });

    log.recommendation(`üéØ Found ${recommendationElements.length} potential recommendation elements`);

    // Limit to 10 recommendations maximum as requested
    const maxRecommendations = 10;
    let extractedCount = 0;

    recommendationElements.forEach((recEl, index) => {
      // Stop if we've reached the maximum
      if (extractedCount >= maxRecommendations) {
        return;
      }

      // IMPROVED: Separate author and text extraction with better debugging
      log.recommendation(`üîç Processing recommendation element ${index + 1}...`);
      log.recommendation(`üîç Element HTML preview: ${recEl.outerHTML.substring(0, 200)}...`);
      
      // First, try to find the author name (usually shorter, looks like a name)
      let author = null;
      const authorSelectors = [
        '.author', 
        '.name', 
        '.client-name',
        '.reviewer-name',
        '.customer-name',
        '.testimonial-author',
        'h3', 'h4', 'h5', 'h6',
        'strong', 'b',
        '[class*="name"]',
        '[class*="author"]'
      ];
      
      // Look for author in child elements
      for (const selector of authorSelectors) {
        const authorEl = recEl.querySelector(selector);
        if (authorEl) {
          const authorText = authorEl.textContent?.trim();
          log.recommendation(`üîç Testing author from ${selector}: "${authorText}"`);
          // Check if it looks like a name (not too long, has proper name patterns)
          if (authorText && authorText.length < 50 && this.looksLikeName(authorText)) {
            author = authorText;
            log.recommendation(`‚úÖ Found author from ${selector}: "${author}"`);
            break;
          } else {
            log.recommendation(`‚ùå Author failed validation: looksLikeName=${this.looksLikeName(authorText)}, length=${authorText?.length}`);
          }
        }
      }
      
      // If no author found in structure, try a different approach
      // Look for the first text node that looks like a name
      if (!author) {
        log.recommendation(`üîç No author found in selectors, trying text node approach...`);
        const allTextElements = recEl.querySelectorAll('*');
        for (const el of allTextElements) {
          const text = el.textContent?.trim();
          // Skip if this element has children (we want leaf nodes)
          if (el.children.length === 0 && text && text.length < 50 && this.looksLikeName(text)) {
            // Make sure this isn't part of a longer recommendation text
            const parentText = el.parentElement?.textContent?.trim();
            if (parentText && text.length < parentText.length * 0.3) { // Name should be much shorter than parent content
              author = text;
              log.recommendation(`‚úÖ Found author from text node: "${author}"`);
              break;
            }
          }
        }
      }
      
      // If still no author, try looking at the very beginning of the element
      if (!author) {
        log.recommendation(`üîç Still no author, trying element text analysis...`);
        const fullText = recEl.textContent?.trim();
        if (fullText) {
          // Try to find name at the beginning of the text
          const lines = fullText.split('\n').map(line => line.trim()).filter(line => line);
          log.recommendation(`üîç Text lines found: ${lines.slice(0, 5).map(line => `"${line}"`).join(', ')}`);
          for (const line of lines.slice(0, 3)) { // Check first 3 lines
            log.recommendation(`üîç Testing line as name: "${line}" (length: ${line.length})`);
            if (line.length < 50 && this.looksLikeName(line)) {
              author = line;
              log.recommendation(`‚úÖ Found author from text lines: "${author}"`);
              break;
            } else {
              log.recommendation(`‚ùå Line failed name test: looksLikeName=${this.looksLikeName(line)}`);
            }
          }
          
          // If still no author, try word patterns from the beginning
          if (!author) {
            const words = fullText.split(/\s+/);
            for (let i = 0; i < Math.min(words.length, 10); i++) {
              for (let j = i + 1; j <= Math.min(i + 3, words.length); j++) {
                const phrase = words.slice(i, j).join(' ');
                if (phrase.length < 50 && this.looksLikeName(phrase)) {
                  author = phrase;
                  log.recommendation(`‚úÖ Found author from word pattern: "${author}"`);
                  break;
                }
              }
              if (author) break;
            }
          }
        }
      }
      
      // Now extract the recommendation text (longer content, not the author)
      let recText = null;
      const textSelectors = [
        'p',
        '.text', 
        '.content', 
        '.recommendation-text',
        '.testimonial-text',
        '.review-content',
        '.feedback-text',
        '[class*="text"]',
        '[class*="content"]',
        'div'
      ];
      
      // Look for text content that's NOT the author
      for (const selector of textSelectors) {
        const textElements = recEl.querySelectorAll(selector);
        for (const textEl of textElements) {
          const text = textEl.textContent?.trim();
          // Make sure it's not the author name and is substantial content
          if (text && text !== author && text.length > 50 && !this.looksLikeName(text)) {
            recText = text;
            log.recommendation(`üîç Found text from ${selector}: "${text.substring(0, 50)}..."`);
            break;
          }
        }
        if (recText) break;
      }
      
      // Fallback: use element's full text but try to separate author from content
      if (!recText) {
        const fullText = recEl.textContent?.trim();
        if (fullText && author && fullText.includes(author)) {
          // Remove author name from the text
          recText = fullText.replace(author, '').trim();
          // Clean up any leftover separators
          recText = recText.replace(/^[-‚Äì‚Äî:\s]+|[-‚Äì‚Äî:\s]+$/g, '').trim();
        } else {
          recText = fullText;
        }
      }
      
      log.recommendation(`üîç Final extraction - Author: "${author}" | Text: "${recText?.substring(0, 100)}..." (length: ${recText?.length})`);
      
      if (recText && this.isValidReviewContent(recText) && recText.length > 30 && recText.length < 1000) {
        log.recommendation(`‚úÖ Text passed validation checks`);
        
        // If we still don't have an author, try extracting from the text
        if (!author) {
          author = this.extractAuthorFromText(recText, recEl);
        }

        const recommendation = {
          id: extractedCount + 1,
          text: this.cleanTextForCSV(recText),
          author: author || 'Anonymous',  // Ensure we always have an author field
          date: this.getTextContent([
            '.date', 
            '.timestamp',
            '.review-date',
            'span:contains("ago")',
            'time'
          ], recEl),
          type: this.getTextContent([
            '.type',
            '.transaction-type',
            '.review-type'
          ], recEl),
          source: 'structured'
        };
        
        // ENHANCED: Check for duplicates before adding
        const isDuplicate = reviews.recommendations.some(existing => 
          this.calculateTextSimilarity(existing.text, recommendation.text) > 0.8 ||
          (existing.author === recommendation.author && 
           this.calculateTextSimilarity(existing.text, recommendation.text) > 0.6)
        );
        
        if (!isDuplicate) {
          reviews.recommendations.push(recommendation);
          extractedCount++;
          log.recommendation(`üéØ Extracted recommendation ${extractedCount}: Author: "${recommendation.author}" | Text: "${recommendation.text.substring(0, 50)}..."`);
        } else {
          log.recommendation(`üîÑ Skipped duplicate recommendation from "${recommendation.author}"`);
        }
      } else {
        log.recommendation(`‚ùå Text failed validation: isValid=${this.isValidReviewContent(recText)}, length=${recText?.length}`);
      }
    });

    log.recommendation(`üéØ Total recommendations extracted: ${extractedCount}/${maxRecommendations}`);
  }

  // Helper method to extract author from text patterns
  extractAuthorFromText(text, element) {
    // Look for common patterns where author names appear
    const authorPatterns = [
      /^([A-Z][a-z]+ [A-Z][a-z]*(?:\s[A-Z]\.?)?)\s*[-‚Äì‚Äî]\s*/,  // "John Smith - recommendation text"
      /[-‚Äì‚Äî]\s*([A-Z][a-z]+ [A-Z][a-z]*(?:\s[A-Z]\.?)?)$/,      // "recommendation text - John Smith"
      /\bby\s+([A-Z][a-z]+ [A-Z][a-z]*(?:\s[A-Z]\.?)?)/i,       // "by John Smith"
      /\bfrom\s+([A-Z][a-z]+ [A-Z][a-z]*(?:\s[A-Z]\.?)?)/i,     // "from John Smith"
      /^([A-Z][a-z]+ [A-Z][a-z]*(?:\s[A-Z]\.?)?)\s*:/,          // "John Smith: recommendation text"
      /\b([A-Z][a-z]+ [A-Z][a-z]*(?:\s[A-Z]\.?)?)\s*says?/i     // "John Smith says"
    ];

    for (const pattern of authorPatterns) {
      const match = text.match(pattern);
      if (match && match[1]) {
        return match[1].trim();
      }
    }

    // Check parent elements for author information
    let parent = element.parentElement;
    while (parent && parent !== document.body) {
      const parentText = parent.textContent;
      for (const pattern of authorPatterns) {
        const match = parentText.match(pattern);
        if (match && match[1] && !text.includes(match[1])) {
          return match[1].trim();
        }
      }
      parent = parent.parentElement;
    }

    return null;
  }

  // Enhanced recommendation extraction for various web page types
  extractRecommendationsFromGenericPage(reviews) {
    log.recommendation('üéØ Performing enhanced recommendation extraction for generic pages...');
    
    const maxRecommendations = 10;
    let currentCount = reviews.recommendations.length;
    
    if (currentCount >= maxRecommendations) {
      log.recommendation(`üéØ Already have ${currentCount} recommendations, skipping generic extraction`);
      return;
    }

    // Look for common recommendation/testimonial containers
    const containerSelectors = [
      '.testimonials-section',
      '.recommendations-section',
      '.reviews-section',
      '.client-feedback',
      '.customer-reviews',
      '[id*="testimonial"]',
      '[id*="recommendation"]',
      '[id*="review"]',
      '[class*="testimonial"]',
      '[class*="recommendation"]',
      '[class*="review"]',
      '.praise',
      '.feedback',
      '.endorsement'
    ];

    const containers = [];
    containerSelectors.forEach(selector => {
      const elements = document.querySelectorAll(selector);
      elements.forEach(el => {
        if (!containers.includes(el)) {
          containers.push(el);
        }
      });
    });

    log.recommendation(`üéØ Found ${containers.length} potential recommendation containers`);

    containers.forEach(container => {
      if (currentCount >= maxRecommendations) return;

      // Look for individual recommendation items within containers
      const itemSelectors = [
        '.item',
        '.card',
        '.block',
        '.entry',
        'blockquote',
        'article',
        'section',
        'div',
        'p'
      ];

      itemSelectors.forEach(selector => {
        if (currentCount >= maxRecommendations) return;

        const items = container.querySelectorAll(selector);
        items.forEach(item => {
          if (currentCount >= maxRecommendations) return;

          const text = item.textContent?.trim();
          if (text && this.isValidRecommendationText(text)) {
            const author = this.extractAuthorFromGenericElement(item);
            
            if (author) {
              // Check for duplicates
              const isDuplicate = reviews.recommendations.some(existing => 
                this.calculateTextSimilarity(existing.text, text) > 0.7 ||
                existing.author === author
              );

              if (!isDuplicate) {
                const recommendation = {
                  id: currentCount + 1,
                  text: this.cleanTextForCSV(text),
                  author: author,
                  date: this.extractDateFromGenericElement(item),
                  source: 'generic_page'
                };

                reviews.recommendations.push(recommendation);
                currentCount++;
                log.recommendation(`üéØ Generic page recommendation ${currentCount}: "${author}" - "${text.substring(0, 50)}..."`);
              }
            }
          }
        });
      });
    });

    log.recommendation(`üéØ Generic page extraction complete: ${currentCount}/${maxRecommendations} total recommendations`);
  }

  // Validate if text looks like a recommendation
  isValidRecommendationText(text) {
    if (!text || text.length < 30 || text.length > 1000) return false;

    // Positive indicators
    const positiveWords = [
      'recommend', 'excellent', 'outstanding', 'professional', 'helpful',
      'great', 'amazing', 'fantastic', 'wonderful', 'best', 'perfect',
      'exceeded', 'impressed', 'satisfied', 'grateful', 'thank you',
      'worked with', 'helped us', 'helped me', 'service', 'experience'
    ];

    // ENHANCED negative indicators (likely not recommendations)
    const negativeWords = [
      'contact us', 'subscribe', 'newsletter', 'privacy policy', 'terms',
      'copyright', 'all rights reserved', 'menu', 'navigation', 'login',
      'register', 'search', 'filter', 'sort by', 'price range', 'last 24 months',
      'experience', 'years', 'website', 'office', 'mobile', 'phone', 'email',
      'address', 'street', 'areas served', 'specializations', 'write', 'review',
      'recommendation', 'not rated yet', 'share profile', 'years price range',
      'buyer\'s agent', 'seller\'s agent', 'commercial', 'residential', 'land',
      'multi-family', 'new construction', 'foreclosures', 'relocation',
      'first time', 'vacation homes', 'waterfront', 'luxury', 'investment',
      'property management', 'hasn\'t provided a bio', 'agent hasn\'t provided',
      '$', 'sqft', 'bed', 'bath', 'property detail', 'rea real estate',
      'better homes and gardens', 'berkshire hathaway', 'nexthome', 'era',
      'quinn agency', 'sotheby\'s international', 'exp realty'
    ];

    const lowerText = text.toLowerCase();
    
    // Check for negative indicators first (MUCH MORE COMPREHENSIVE)
    if (negativeWords.some(word => lowerText.includes(word))) {
      log.recommendation(`‚ùå Rejected text (contains "${negativeWords.find(word => lowerText.includes(word))}"): "${text.substring(0, 50)}..."`);
      return false;
    }

    // Reject if text looks like a price range
    if (text.match(/\$[\d,]+/)) {
      log.recommendation(`‚ùå Rejected text (contains price): "${text.substring(0, 50)}..."`);
      return false;
    }

    // Reject if text looks like agent info
    if (text.match(/\(\d{3}\)\s*\d{3}-\d{4}/) || text.match(/\d{3}-\d{4}/)) {
      log.recommendation(`‚ùå Rejected text (contains phone): "${text.substring(0, 50)}..."`);
      return false;
    }

    // Reject if text contains only names/places
    if (text.match(/^[A-Z][a-z]+(?:\s[A-Z][a-z]+)*$/) && text.split(' ').length < 4) {
      log.recommendation(`‚ùå Rejected text (looks like name only): "${text.substring(0, 50)}..."`);
      return false;
    }

    // Check for positive indicators
    const hasPositiveWords = positiveWords.some(word => lowerText.includes(word));
    
    // Check for sentence structure (recommendations usually have complete sentences)
    const sentenceCount = (text.match(/[.!?]+/g) || []).length;
    const hasProperSentences = sentenceCount > 0 && text.length / sentenceCount > 15;

    // Must have both positive words AND proper sentences to be valid
    const isValid = hasPositiveWords && hasProperSentences;
    
    if (!isValid) {
      log.recommendation(`‚ùå Rejected text (no positive words or sentences): "${text.substring(0, 50)}..."`);
    }

    return isValid;
  }

  // Extract author from generic page elements
  extractAuthorFromGenericElement(element) {
    // Look for author in nearby elements (siblings, parent, children)
    const searchElements = [
      element,
      element.nextElementSibling,
      element.previousElementSibling,
      element.parentElement,
      ...Array.from(element.children)
    ].filter(el => el);

    for (const el of searchElements) {
      if (!el) continue;

      // Look for elements that might contain author names
      const authorElements = el.querySelectorAll([
        '.author',
        '.name',
        '.by-line',
        '.attribution',
        'cite',
        'footer',
        'header',
        'strong',
        'b',
        'em',
        'i'
      ].join(','));

      for (const authorEl of authorElements) {
        const text = authorEl.textContent?.trim();
        if (text && this.looksLikeName(text)) {
          return text;
        }
      }

      // Check element's own text for name patterns
      const elementText = el.textContent?.trim();
      if (elementText && elementText !== element.textContent?.trim()) {
        const nameMatch = elementText.match(/([A-Z][a-z]+ [A-Z][a-z]*(?:\s[A-Z]\.?)?)/);
        if (nameMatch && this.looksLikeName(nameMatch[1])) {
          return nameMatch[1];
        }
      }
    }

    return null;
  }

  // Extract date from generic page elements
  extractDateFromGenericElement(element) {
    const searchElements = [
      element,
      element.nextElementSibling,
      element.previousElementSibling,
      element.parentElement
    ].filter(el => el);

    for (const el of searchElements) {
      if (!el) continue;

      const text = el.textContent?.trim();
      if (!text) continue;

      // Look for various date patterns
      const datePatterns = [
        /(\d{1,2}\/\d{1,2}\/\d{4})/,
        /(\d{1,2}-\d{1,2}-\d{4})/,
        /(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{1,2},?\s+\d{4}/i,
        /(\d+\s+(?:days?|weeks?|months?|years?)\s+ago)/i,
        /(\d{4})/
      ];

      for (const pattern of datePatterns) {
        const match = text.match(pattern);
        if (match) {
          return match[1];
        }
      }
    }

    return null;
  }

  // Check if text looks like a person's name
  looksLikeName(text) {
    if (!text || text.length < 2 || text.length > 50) return false;
    
    // Basic name pattern: starts with capital letter, contains letters and spaces
    const namePattern = /^[A-Z][a-z]+(?:\s[A-Z][a-z]*)*(?:\s[A-Z]\.?)?$/;
    
    // Exclude common non-name words and patterns
    const excludeWords = [
      'Read More', 'Learn More', 'Contact', 'About', 'Home', 'Services',
      'Reviews', 'Testimonials', 'Menu', 'Search', 'Login', 'Register',
      'Write', 'Price', 'Experience', 'Bangor', 'Nexthome', 'Better Homes',
      'Berkshire Hathaway', 'ERA', 'Quinn Agency', 'Realty', 'Real Estate',
      'Agent', 'Broker', 'Office', 'Mobile', 'Phone', 'Email', 'Website',
      'Areas', 'Served', 'Specializations', 'Commercial', 'Residential',
      'Buyer', 'Seller', 'Land', 'Multi', 'Family', 'New Construction',
      'Foreclosures', 'Relocation', 'First Time', 'Vacation Homes',
      'Waterfront', 'Luxury', 'Investment', 'Property Management',
      'Anonymous', 'Verified', 'Client', 'Customer', 'User',
      // NEW: Block the specific invalid names we've been seeing
      'Sourced', 'Comfort Real E', 'Los Angeles', 'Camarillo', 'Oxnard',
      'Port Hueneme', 'Agoura Hills', 'Santa Paula', 'Ventura County',
      'California', 'Eleven', 'Twenty Nine', 'Realtor', 'Magazine'
    ];
    
    // Exclude text that contains phone numbers or prices
    if (text.match(/\d{3}-\d{4}|\$[\d,]+/)) {
      return false;
    }
    
    // Exclude very common single words that aren't names
    if (!text.includes(' ') && excludeWords.some(word => text.toLowerCase().includes(word.toLowerCase()))) {
      return false;
    }
    
    // Exclude city/location names and partial business names
    if (text.match(/^(Los Angeles|Camarillo|Oxnard|Santa Paula|Agoura Hills|Port Hueneme)$/i)) {
      return false;
    }
    
    // Exclude partial business names
    if (text.includes('Real E') || text.includes('Comfort Real')) {
      return false;
    }
    
    // Exclude numbers written as words
    if (text.match(/^(Twenty|Thirty|Eleven|Twelve|Thirteen|Fourteen|Fifteen)$/i)) {
      return false;
    }
    
    return namePattern.test(text) && !excludeWords.some(word => text.includes(word));
  }

  extractReviewsByText(reviews) {
    // Extract reviews from text content when structured selectors don't work
    const pageText = document.body.textContent;
    
    // Look for verified review patterns
    const verifiedReviewPattern = /Verified review\s+(.*?)\s+(\d{4})\s+Overall rating \((\d+)\)/g;
    let match;
    
    while ((match = verifiedReviewPattern.exec(pageText)) !== null) {
      const [, location, year, rating] = match;
      
      // Find the review text that follows
      const afterMatch = pageText.substring(match.index + match[0].length);
      const reviewTextMatch = afterMatch.match(/^[^\.]+\.[^\.]+\./);
      
      if (reviewTextMatch) {
        reviews.individual.push({
          rating: rating,
          text: reviewTextMatch[0].trim(),
          location: location,
          date: year,
          verified: true,
          categories: {}
        });
      }
    }
    
    // Look for recommendation patterns
    const recommendationPattern = /([\w\s&]+)\s+almost (\d+) years ago\s+([^]+?)(?=\w+\s+almost|\w+\s+about|$)/g;
    
    while ((match = recommendationPattern.exec(pageText)) !== null) {
      const [, author, yearsAgo, text] = match;
      
      if (text && text.trim().length > 20) {
        reviews.recommendations.push({
          author: author.trim(),
          date: `${yearsAgo} years ago`,
          text: text.trim()
        });
      }
    }
  }

  async extractListings() {
    // Delegate to external ListingsExtractor module
    if (window.ListingsExtractor) {
      const listingsExtractor = new window.ListingsExtractor();
      return await listingsExtractor.extractListings();
    } else {
      log.error('ListingsExtractor module not loaded, using fallback');
      return {
        active: [],
        sold: [],
        metadata: {
          totalFound: 0,
          totalExtracted: 0,
          error: 'ListingsExtractor module not available'
        }
      };
    }
  }

  // Enhanced listings extraction with property limit
  async extractListingsWithLimit(maxProperties = 20) {
    // Delegate to external ListingsExtractor module
    if (window.ListingsExtractor) {
      const listingsExtractor = new window.ListingsExtractor();
      return await listingsExtractor.extractListingsWithLimit(maxProperties);
    } else {
      log.error('ListingsExtractor module not loaded, using fallback');
      return {
        active: [],
        sold: [],
        metadata: {
          totalFound: 0,
          totalExtracted: 0,
          error: 'ListingsExtractor module not available'
        }
      };
    }
  }

  // Enhanced extraction with property counting and smart stopping
  async performListingsExtractionWithLimit(maxProperties = 20) {
    // Delegate to external ListingsExtractor module
    if (window.ListingsExtractor) {
      const listingsExtractor = new window.ListingsExtractor();
      return await listingsExtractor.performListingsExtractionWithLimit(maxProperties);
    } else {
      log.error('ListingsExtractor module not loaded, using fallback');
      return {
        active: [],
        sold: [],
        metadata: {
          totalFound: 0,
          totalExtracted: 0,
          error: 'ListingsExtractor module not available'
        }
      };
    }
  }

  // Enhanced text extraction with limit
  extractListingsFromTextWithLimit(listings, remainingSlots) {
    if (remainingSlots <= 0) return;
    

    
    const pageText = document.body.textContent;
    
    // Look for patterns like "For sale - 08/14/2025" followed by price and property info
    const listingPatterns = [
      /For sale - \d{2}\/\d{2}\/\d{4}[\s\S]*?\$[\d,]+[\s\S]*?\d+ bed[\s\S]*?\d+ bath[\s\S]*?\d+,?\d* sqft/gi,
      /Sold - \d{2}\/\d{2}\/\d{4}[\s\S]*?\$[\d,]+[\s\S]*?\d+ bed[\s\S]*?\d+ bath[\s\S]*?\d+,?\d* sqft/gi
    ];

    let extracted = 0;
    listingPatterns.forEach(pattern => {
      if (extracted >= remainingSlots) return;
      
      const matches = pageText.match(pattern);
      if (matches) {
        matches.forEach((match, index) => {
          if (extracted >= remainingSlots) return;
          
          const listing = this.parseListingFromText(match, `text-${index}`);
          if (listing) {
            if (match.toLowerCase().includes('sold')) {
              listings.sold.push(listing);
            } else {
              listings.active.push(listing);
            }
            extracted++;
            listings.metadata.totalExtracted++;

          }
        });
      }
    });
    

  }
  
  // Enhanced method to find all listing elements efficiently
  findAllListingElements() {
    // Delegate to external ListingsExtractor module
    if (window.ListingsExtractor) {
      const listingsExtractor = new window.ListingsExtractor();
      return listingsExtractor.findAllListingElements();
    } else {
      log.error('ListingsExtractor module not loaded, using fallback');
      const elements = document.querySelectorAll('[data-testid*="listing"], .property-card, .listing-card');
      return Array.from(elements);
    }
  }
  clickAllListingsTabSafely() {
    // PREVENT INFINITE LOOPS: Only allow one execution per page
    if (this._tabClickingInProgress || this._tabsAlreadyClicked) {

      return 0;
    }
    
    this._tabClickingInProgress = true;
    

    
    // Find all potential tab containers in the listings section
    const listingsSection = document.querySelector('[data-testid="agent-listing-and-sales"], #listing-and-sales-section') || document;
    
    // Enhanced selector - look for ANY clickable element containing the tab text patterns
    const allClickableElements = listingsSection.querySelectorAll('button, [role="tab"], .tab, .picker-button, [data-testid*="picker"], a, span, div[class*="picker"], div[class*="tab"], [class*="button"]');
    
    // ALSO directly search for elements containing the specific text we know exists
    const textBasedTabs = [];
    const walker = document.createTreeWalker(
      listingsSection,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    let node;
    while (node = walker.nextNode()) {
      const text = node.textContent.trim();
      if ((text.includes('All') && text.match(/\(\d+\)/)) ||
          (text.includes('Active Listings') && text.match(/\(\d+\)/)) ||
          (text.includes('Worked with Buyer') && text.match(/\(\d+\)/))) {
        const parentElement = node.parentElement;
        if (parentElement && !textBasedTabs.includes(parentElement)) {
          textBasedTabs.push(parentElement);

        }
      }
    }
    
    // Combine both approaches
    const combinedElements = [...allClickableElements, ...textBasedTabs];
    
    let tabsClicked = 0;
    const clickedTabs = [];
    
    for (let i = 0; i < combinedElements.length; i++) {
      const element = combinedElements[i];
      const text = element.textContent.trim();
      const lowerText = text.toLowerCase();
      const testId = element.getAttribute('data-testid') || '';
      
      // Skip if we already clicked a tab with this text
      if (clickedTabs.includes(text)) {

        continue;
      }
      
      // Target specific tab patterns for listings
      const isAllTab = lowerText.includes('all') && text.match(/\(\d+\)/);
      const isWorkedWithBuyerTab = lowerText.includes('worked with buyer') && text.match(/\(\d+\)/);
      const isActiveListingsTab = lowerText.includes('active listings') && text.match(/\(\d+\)/);
      const isSoldTab = (lowerText.includes('sold') || lowerText.includes('closed') || lowerText.includes('history')) && text.match(/\(\d+\)/);
      
      // SKIP INDIVIDUAL PROPERTIES: Don't click on individual property tabs
      const isIndividualProperty = (
        text.includes('Community detail for') ||
        text.includes('bed') && text.includes('bath') && text.includes('sqft') ||
        text.includes('For Sale$') ||
        text.includes('SoldContact for price') ||
        text.match(/\d+bed\d+bath/) ||
        text.match(/\$\d+[kmK]/) // Price patterns like $470k
      );
      
      if (isIndividualProperty) {
        if (i < 5) { // Only log first few to avoid spam

        }
        continue;
      }
      
      // Debug: Log what we're finding (but limit to prevent spam)
      if (i < 10) { // Only log first 10 to prevent log spam

      } else if (i === 10) {

      }
      
      // Skip if this is not in the listings area (avoid header/nav clicks)
      if (element.closest('header, nav, .header, .navigation, .main-nav')) {

        continue;
      }
      
      // Only click on CATEGORY tabs, not individual properties
      if (isAllTab || isWorkedWithBuyerTab || isActiveListingsTab || isSoldTab) {

        
        // Try multiple click strategies
        let clickSuccess = false;
        const clickStrategies = [
          () => element.click(),
          () => element.parentElement?.click(),
          () => element.parentElement?.parentElement?.click(),
          () => {
            // Dispatch a click event
            const clickEvent = new MouseEvent('click', { bubbles: true, cancelable: true });
            element.dispatchEvent(clickEvent);
          },
          () => {
            // Try to find and click any button/clickable element nearby
            const nearbyClickable = element.closest('button, [role="button"], [class*="button"], a') || 
                                  element.querySelector('button, [role="button"], [class*="button"], a') ||
                                  element.parentElement?.querySelector('button, [role="button"], [class*="button"], a');
            nearbyClickable?.click();
          }
        ];
        
        for (let j = 0; j < clickStrategies.length && !clickSuccess; j++) {
          try {
            clickStrategies[j]();
            clickSuccess = true;
            tabsClicked++;
            clickedTabs.push(text);

            
            // Small delay between clicks to allow content to load
            const start = Date.now();
            while (Date.now() - start < 1000) { /* wait */ }
            break;
            
          } catch (e) {

          }
        }
        
        if (!clickSuccess) {

        }
      }
    }
    
    
    // Mark as completed and cleanup
    this._tabClickingInProgress = false;
    this._tabsAlreadyClicked = true;
    
    if (tabsClicked > 0) {

    } else {

    }
    
    return tabsClicked;
  }
  
  // DISABLED: Old aggressive tab activation method - caused navigation issues
  /*
  activateAllPropertyTabs() {
    log.debug('üéØ ACTIVATING PROPERTY TABS - Looking for sold/history tabs to reveal sold properties...');

    
    // PHASE 1: Look for specific sold/history tabs
    const soldTabSelectors = [
      'button[data-testid*="sold"]',
      'button[data-testid*="history"]',
      'button[data-testid*="past"]',
      'a[href*="sold"]',
      'a[href*="history"]',
      '[role="tab"][aria-label*="sold"]',
      '[role="tab"][aria-label*="history"]',
      '.tab[data-tab*="sold"]',
      '.nav-link[href*="sold"]'
    ];
    
    let soldTabsFound = 0;
    soldTabSelectors.forEach(selector => {
      try {
        const elements = document.querySelectorAll(selector);
        if (elements.length > 0) {

          elements.forEach(el => {

            el.click();
            soldTabsFound++;
          });
        }
      } catch (e) {
        // Continue if selector fails
      }
    });
    
    // PHASE 2: Broader search for any clickable element with sold-related text
    const allClickableElements = document.querySelectorAll('button, a, [role="tab"], [role="button"], [onclick], .tab, .nav-link, .button');
    let generalTabsFound = 0;
    const clickedElements = new Set();
    
    allClickableElements.forEach(element => {
      if (clickedElements.has(element)) return;
      
      const text = element.textContent.toLowerCase().trim();
      const ariaLabel = (element.getAttribute('aria-label') || '').toLowerCase();
      const title = (element.getAttribute('title') || '').toLowerCase();
      const href = (element.getAttribute('href') || '').toLowerCase();
      const dataTestId = (element.getAttribute('data-testid') || '').toLowerCase();
      const className = (element.className || '').toLowerCase();
      
      const allText = `${text} ${ariaLabel} ${title} ${href} ${dataTestId} ${className}`;
      
      const soldKeywords = ['sold', 'history', 'past', 'previous', 'closed', 'transaction', 'historical'];
      const hasKeyword = soldKeywords.some(keyword => allText.includes(keyword));
      
      if (hasKeyword || (text.includes('more') && text.length < 30)) { // "View more", "Show more", "Load more"
        log.debug(`üéØ Found potential sold tab: "${text}" (${element.tagName}, class: ${element.className})`);

        
        try {
          element.click();
          clickedElements.add(element);
          generalTabsFound++;
          
          // Multiple click strategies for stubborn elements
          if (element.dispatchEvent) {
            element.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
            element.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
            element.dispatchEvent(new MouseEvent('dblclick', { bubbles: true }));
          }
          
          // Try focus and enter key as well
          if (element.focus) {
            element.focus();
            element.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', bubbles: true }));
          }
        } catch (clickError) {
          log.debug('Click failed:', clickError);
        }
      }
    });
    
    const totalTabsActivated = soldTabsFound + generalTabsFound;




    
    // PHASE 3: Try to trigger any lazy-loading or "Show more" buttons
    const showMoreSelectors = [
      'button[data-testid*="more"]',
      'button[aria-label*="more"]',
      '.show-more',
      '.load-more',
      '.view-more',
      'button:contains("more")',
      'a:contains("more")'
    ];
    
    let loadMoreFound = 0;
    showMoreSelectors.forEach(selector => {
      try {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          if (!clickedElements.has(el)) {

            el.click();
            clickedElements.add(el);
            loadMoreFound++;
          }
        });
      } catch (e) {
        // Continue if selector fails
      }
    });
    
    if (loadMoreFound > 0) {

    }
    
    // Also try to scroll to reveal more content - sometimes this triggers lazy loading
    window.scrollTo(0, document.body.scrollHeight);
    window.scrollTo(0, 0);
    
    // Wait longer for any AJAX/dynamic content to load after clicking tabs
    const waitTime = totalTabsActivated > 0 ? 2000 : 200; // Increased wait time

  }
  */
  
  performListingsExtraction() {
    log.debug('Starting listings extraction...');
    
    // Debug: Check what's actually on the page
    log.debug('üîç Page structure analysis:');
    log.debug(`- Total divs: ${document.querySelectorAll('div').length}`);
    log.debug(`- Elements with "card" in class: ${document.querySelectorAll('[class*="card"]').length}`);
    log.debug(`- Elements with "property" in class: ${document.querySelectorAll('[class*="property"]').length}`);
    log.debug(`- Elements with "listing" in class: ${document.querySelectorAll('[class*="listing"]').length}`);
    log.debug(`- Elements with data-testid: ${document.querySelectorAll('[data-testid]').length}`);
    
    // Check for different page sections
    const sections = document.querySelectorAll('section, [role="main"], main, [class*="content"]');
    log.debug(`- Page sections found: ${sections.length}`);
    
    const listings = {
      active: [],
      sold: [],
      totalActive: 0,
      totalSold: 0
    };

    // Extract listing counts
    listings.totalActive = this.getNumberFromText([
      '[data-testid="active-listings-count"]',
      '.active-listings-count',
      '.listings-active'
    ]);

    listings.totalSold = this.getNumberFromText([
      '[data-testid="sold-listings-count"]',
      '.sold-listings-count',
      '.listings-sold'
    ]);

    log.debug('Listing counts:', { active: listings.totalActive, sold: listings.totalSold });

    // Comprehensive listing detection - get all potential property cards
    const listingSelectors = [
      '[data-testid="card-content"]',  // This was working before
      '[data-testid="listing-item"]',
      '.listing-item',
      '.property-card',
      '.BasePropertyCard',
      '.PropertyCard',
      '.card-content',
      '.listing-card',
      'div[class*="property"]',
      'div[class*="listing"]',
      'div[class*="card"]',
      'article[class*="property"]',
      'article[class*="listing"]',
      // Add more modern React-based selectors
      '[class*="Card"]',
      '[class*="Listing"]',
      '[class*="Property"]',
      'div[role="article"]',
      'article',
      // Add broader selectors to catch more
      'div[class*="Item"]',
      'div[class*="Container"]', 
      'section > div',
      '[data-testid*="item"]',
      '[data-testid*="card"]',
      '[data-testid*="result"]',
      // Try React component patterns
      'div[class*="_"]', // React often uses underscores in class names
      'li[class*="item"]',
      'li[class*="card"]'
    ];

    let allElements = [];
    listingSelectors.forEach(selector => {
      try {
        const elements = document.querySelectorAll(selector);
        log.debug(`üîç Selector "${selector}" found ${elements.length} elements`);
        elements.forEach(el => {
          if (!allElements.includes(el)) {
            allElements.push(el);
          }
        });
      } catch (e) {
        log.debug(`‚ùå Selector failed: ${selector}`, e);
      }
    });

    log.debug(`üìã Total unique elements found: ${allElements.length}`);

    // Also try a broader search for price patterns in the DOM
    const priceElements = document.querySelectorAll('*');
    let priceContainingElements = [];
    
    priceElements.forEach(el => {
      const text = el.textContent || '';
      if ((text.match(/\$[\d,]+/) || text.toLowerCase().includes('contact for price')) && 
          text.length < 1000 && text.length > 20) {
        priceContainingElements.push(el);
      }
    });
    
    log.debug(`üí∞ Found ${priceContainingElements.length} elements containing prices`);
    
    // Combine both approaches
    priceContainingElements.forEach(el => {
      if (!allElements.includes(el)) {
        allElements.push(el);
      }
    });

    log.debug(`üìä Final element count after price search: ${allElements.length}`);
    log.debug(`Found ${allElements.length} potential listing elements to check`);

    // Less restrictive filtering - focus on elements with price and property data
    const elementsWithPropertyInfo = allElements.filter(el => {
      const text = el.textContent || '';
      
      // Must have a price pattern OR "contact for price"
      const hasPrice = text.match(/\$[\d,]+(?:\.\d+)?[KMB]?/i) || 
                       text.toLowerCase().includes('contact for price') ||
                       text.toLowerCase().includes('call for price');
      if (!hasPrice) return false;
      
      // Must have some property indicators (MADE MORE FLEXIBLE)
      const hasPropertyIndicators = text.match(/\d+\s*bed/) || 
                                   text.match(/\d+\s*bath/) || 
                                   text.match(/\d+,?\d*\s*sq/) ||
                                   text.match(/\d+\s+\w+\s+(St|Ave|Dr|Rd|Ln|Ct|Blvd|Way|Drive|Street|Avenue|Road|Lane|Court|Boulevard)/) ||
                                   text.match(/\w+,\s*[A-Z]{2}\s*\d{5}/) ||
                                   text.match(/\w+\s+in\s+\w+/) || // "San Francesca in Camarillo"
                                   text.match(/Condo|Townhouse|House|Single Family|Multi Family/i) ||
                                   text.match(/For Sale|Sold|Active|Pending/i);
      
      // Basic filtering - avoid navigation and very small/large elements (MADE MORE FLEXIBLE)
      const isValidSize = text.length > 20 && text.length < 8000; // Increased max size
      const notNavigation = !text.toLowerCase().includes('navigation') &&
                           !text.toLowerCase().includes('header') &&
                           !text.toLowerCase().includes('footer') &&
                           !text.toLowerCase().includes('menu');
      
      const isValidContent = hasPrice && hasPropertyIndicators && isValidSize && notNavigation;
      
      if (isValidContent) {
        log.debug(`‚úÖ VALID PROPERTY ELEMENT: Price=${hasPrice[0]}, Size=${text.length}, Text preview: "${text.substring(0, 100)}..."`);
      }
      
      return isValidContent;
    });

    log.debug(`Found ${elementsWithPropertyInfo.length} elements with valid property information`);
    
    // DIAGNOSTIC: Show what we found
    elementsWithPropertyInfo.forEach((el, i) => {
      const text = el.textContent || '';
      const priceMatch = text.match(/\$[\d,]+(?:\.\d+)?[KMB]?/i);
      log.debug(`üè† Property Element ${i+1}: Price=${priceMatch ? priceMatch[0] : 'none'}, Text="${text.substring(0, 150)}..."`);
    });

    // Increase limit to capture more properties 
    const maxListings = 20; // Increased from 10
    const limitedElements = elementsWithPropertyInfo.slice(0, maxListings);

    limitedElements.forEach((listingEl, index) => {
      const listing = this.extractDetailedListing(listingEl, index);
      
      if (listing && listing.price) {
        log.debug(`Extracted listing ${index}:`, JSON.stringify(listing, null, 2));
        
        // CRITICAL: Check for duplicates before adding
        const isDuplicate = this.isListingDuplicate(listing, listings.active, listings.sold);
        
        if (isDuplicate) {
          log.debug(`üö´ DUPLICATE LISTING REJECTED: ${listing.address || 'No address'} - ${listing.price}`);
          return; // Skip this duplicate
        }
        
        if (listing.status?.toLowerCase().includes('sold') || 
            listingEl.textContent.toLowerCase().includes('sold')) {
          listings.sold.push(listing);
          log.debug(`‚úÖ ADDED SOLD LISTING: ${listing.address || 'No address'} - ${listing.price}`);
          console.log(`üè† SOLD PROPERTY DETECTED:`, {
            address: listing.address,
            price: listing.price,
            status: listing.status,
            elementText: listingEl.textContent.substring(0, 100)
          });
        } else {
          listings.active.push(listing);
          log.debug(`‚úÖ ADDED ACTIVE LISTING: ${listing.address || 'No address'} - ${listing.price}`);
          console.log(`üè† ACTIVE PROPERTY DETECTED:`, {
            address: listing.address,
            price: listing.price,
            status: listing.status,
            elementText: listingEl.textContent.substring(0, 100)
          });
        }
      }
    });

    log.debug('Final listings result:', {
      activeCount: listings.active.length,
      soldCount: listings.sold.length,
      totalActive: listings.totalActive,
      totalSold: listings.totalSold,
      totalExtracted: listings.active.length + listings.sold.length
    });

    // DIAGNOSTIC: Show what we actually found




    
    if (listings.active.length > 0) {

      listings.active.slice(0, 3).forEach((listing, i) => {

      });
    }
    
    if (listings.sold.length > 0) {
  
      listings.sold.slice(0, 3).forEach((listing, i) => {

      });
    }

    return listings;
  }
  
  performListingsExtraction() {
    log.debug('üìä Performing main listings extraction after tab activation...');
    
    // Debug: Check what's actually on the page
    log.debug('üîç Page structure analysis:');
    log.debug(`- Total divs: ${document.querySelectorAll('div').length}`);
    log.debug(`- Elements with "card" in class: ${document.querySelectorAll('[class*="card"]').length}`);
    log.debug(`- Elements with "property" in class: ${document.querySelectorAll('[class*="property"]').length}`);
    log.debug(`- Elements with "listing" in class: ${document.querySelectorAll('[class*="listing"]').length}`);
    log.debug(`- Elements with data-testid: ${document.querySelectorAll('[data-testid]').length}`);
    
    // Check for different page sections
    const sections = document.querySelectorAll('section, [role="main"], main, [class*="content"]');
    log.debug(`- Page sections found: ${sections.length}`);
    
    const listings = {
      active: [],
      sold: [],
      totalActive: 0,
      totalSold: 0
    };

    // Extract listing counts
    listings.totalActive = this.getNumberFromText([
      '[data-testid="active-listings-count"]',
      '.active-listings-count',
      '.listings-active'
    ]);

    listings.totalSold = this.getNumberFromText([
      '[data-testid="sold-listings-count"]',
      '.sold-listings-count',
      '.listings-sold'
    ]);

    log.debug('Listing counts:', { active: listings.totalActive, sold: listings.totalSold });

    // Comprehensive listing detection - get all potential property cards
    const listingSelectors = [
      '[data-testid="card-content"]',  // This was working before
      '[data-testid="listing-item"]',
      '.listing-item',
      '.property-card',
      '.BasePropertyCard',
      '.PropertyCard',
      '.card-content',
      '.listing-card',
      'div[class*="property"]',
      'div[class*="listing"]',
      'div[class*="card"]',
      'article[class*="property"]',
      'article[class*="listing"]',
      // Add more modern React-based selectors
      '[class*="Card"]',
      '[class*="Listing"]',
      '[class*="Property"]',
      'div[role="article"]',
      'article',
      // Add broader selectors to catch more
      'div[class*="Item"]',
      'div[class*="Container"]', 
      'section > div',
      '[data-testid*="item"]',
      '[data-testid*="card"]',
      '[data-testid*="result"]',
      // Try React component patterns
      'div[class*="_"]', // React often uses underscores in class names
      'li[class*="item"]',
      'li[class*="card"]'
    ];

    let allElements = [];
    listingSelectors.forEach(selector => {
      try {
        const elements = document.querySelectorAll(selector);
        log.debug(`üîç Selector "${selector}" found ${elements.length} elements`);
        elements.forEach(el => {
          if (!allElements.includes(el)) {
            allElements.push(el);
          }
        });
      } catch (e) {
        log.debug(`‚ùå Selector failed: ${selector}`, e);
      }
    });

    log.debug(`üìã Total unique elements found: ${allElements.length}`);

    // Also try a broader search for price patterns in the DOM
    const priceElements = document.querySelectorAll('*');
    let priceContainingElements = [];
    
    priceElements.forEach(el => {
      const text = el.textContent || '';
      if ((text.match(/\$[\d,]+/) || text.toLowerCase().includes('contact for price')) && 
          text.length < 1000 && text.length > 20) {
        priceContainingElements.push(el);
      }
    });
    
    log.debug(`üí∞ Found ${priceContainingElements.length} elements containing prices`);
    
    // Combine both approaches
    priceContainingElements.forEach(el => {
      if (!allElements.includes(el)) {
        allElements.push(el);
      }
    });

    log.debug(`üìä Final element count after price search: ${allElements.length}`);
    log.debug(`Found ${allElements.length} potential listing elements to check`);

    // Less restrictive filtering - focus on elements with price and property data
    const elementsWithPropertyInfo = allElements.filter(el => {
      const text = el.textContent || '';
      
      // Must have a price pattern OR "contact for price"
      const hasPrice = text.match(/\$[\d,]+(?:\.\d+)?[KMB]?/i) || 
                       text.toLowerCase().includes('contact for price') ||
                       text.toLowerCase().includes('call for price');
      if (!hasPrice) return false;
      
      // Must have some property indicators (MADE MORE FLEXIBLE)
      const hasPropertyIndicators = text.match(/\d+\s*bed/) || 
                                   text.match(/\d+\s*bath/) || 
                                   text.match(/\d+,?\d*\s*sq/) ||
                                   text.match(/\d+\s+\w+\s+(St|Ave|Dr|Rd|Ln|Ct|Blvd|Way|Drive|Street|Avenue|Road|Lane|Court|Boulevard)/) ||
                                   text.match(/\w+,\s*[A-Z]{2}\s*\d{5}/) ||
                                   text.match(/\w+\s+in\s+\w+/) || // "San Francesca in Camarillo"
                                   text.match(/Condo|Townhouse|House|Single Family|Multi Family/i) ||
                                   text.match(/For Sale|Sold|Active|Pending/i);
      
      // Basic filtering - avoid navigation and very small/large elements (MADE MORE FLEXIBLE)
      const isValidSize = text.length > 20 && text.length < 8000; // Increased max size
      const notNavigation = !text.toLowerCase().includes('navigation') &&
                           !text.toLowerCase().includes('header') &&
                           !text.toLowerCase().includes('footer') &&
                           !text.toLowerCase().includes('menu');
      
      const isValidContent = hasPrice && hasPropertyIndicators && isValidSize && notNavigation;
      
      if (isValidContent) {
        log.debug(`‚úÖ VALID PROPERTY ELEMENT: Price=${hasPrice[0] || 'contact for price'}, Size=${text.length}, Text preview: "${text.substring(0, 100)}..."`);
      }
      
      return isValidContent;
    });

    log.debug(`Found ${elementsWithPropertyInfo.length} elements with valid property information`);
    
    // DIAGNOSTIC: Show what we found
    elementsWithPropertyInfo.forEach((el, i) => {
      const text = el.textContent || '';
      const priceMatch = text.match(/\$[\d,]+(?:\.\d+)?[KMB]?/i);
      const hasContactPrice = text.toLowerCase().includes('contact for price');
      log.debug(`üè† Property Element ${i+1}: Price=${priceMatch ? priceMatch[0] : (hasContactPrice ? 'Contact for price' : 'none')}, Text="${text.substring(0, 150)}..."`);
    });

    // Increase limit to capture more properties 
    const maxListings = 20; // Increased from 10
    const limitedElements = elementsWithPropertyInfo.slice(0, maxListings);

    limitedElements.forEach((listingEl, index) => {
      const listing = this.extractDetailedListing(listingEl, index);
      
      if (listing && listing.price) {
        log.debug(`Extracted listing ${index}:`, JSON.stringify(listing, null, 2));
        
        // CRITICAL: Check for duplicates before adding
        const isDuplicate = this.isListingDuplicate(listing, listings.active, listings.sold);
        
        if (isDuplicate) {
          log.debug(`üö´ DUPLICATE LISTING REJECTED: ${listing.address || 'No address'} - ${listing.price}`);
          return; // Skip this duplicate
        }
        
        if (listing.status?.toLowerCase().includes('sold') || 
            listingEl.textContent.toLowerCase().includes('sold')) {
          listings.sold.push(listing);
          log.debug(`‚úÖ ADDED SOLD LISTING: ${listing.address || 'No address'} - ${listing.price}`);
          console.log(`üè† SOLD PROPERTY DETECTED:`, {
            address: listing.address,
            price: listing.price,
            status: listing.status,
            elementText: listingEl.textContent.substring(0, 100)
          });
        } else {
          listings.active.push(listing);
          log.debug(`‚úÖ ADDED ACTIVE LISTING: ${listing.address || 'No address'} - ${listing.price}`);
          console.log(`üè† ACTIVE PROPERTY DETECTED:`, {
            address: listing.address,
            price: listing.price,
            status: listing.status,
            elementText: listingEl.textContent.substring(0, 100)
          });
        }
      }
    });

    log.debug('Final listings result:', {
      activeCount: listings.active.length,
      soldCount: listings.sold.length,
      totalActive: listings.totalActive,
      totalSold: listings.totalSold,
      totalExtracted: listings.active.length + listings.sold.length
    });

    // DIAGNOSTIC: Show what we actually found




    
    if (listings.active.length > 0) {

      listings.active.slice(0, 3).forEach((listing, i) => {

      });
    }
    
    if (listings.sold.length > 0) {
  
      listings.sold.slice(0, 3).forEach((listing, i) => {

      });
    }

    return listings;
  }

  // ENHANCED: Duplicate detection for listings with global database check capability
  isListingDuplicate(newListing, activeListings, soldListings) {
    const allListings = [...activeListings, ...soldListings];
    
    return allListings.some(existingListing => {
      // Primary check: Same property_id (most reliable)
      if (newListing.property_id && existingListing.property_id) {
        if (newListing.property_id === existingListing.property_id) {
          log.debug(`üö´ DUPLICATE DETECTED: Same property_id ${newListing.property_id}`);
          return true; // Exact property ID match = definite duplicate
        }
      }
      
      // Secondary check: Same MLS number (also very reliable)
      if (newListing.mls && existingListing.mls) {
        if (newListing.mls === existingListing.mls) {
          log.debug(`üö´ DUPLICATE DETECTED: Same MLS ${newListing.mls}`);
          return true; // Same MLS = duplicate
        }
      }
      
      // Tertiary check: Same address (strong indicator) - ENHANCED FOR MINIMAL DATA
      if (newListing.address && existingListing.address) {
        const newAddr = this.normalizeAddress(newListing.address);
        const existingAddr = this.normalizeAddress(existingListing.address);
        if (newAddr === existingAddr) {
          log.info(`üö´ DUPLICATE DETECTED: Same address "${newAddr}" - blocking duplicate property`);
          return true; // Exact address match = duplicate
        }
        
        // ADDITIONAL: Check for address similarity for minimal data properties
        if (this.isMinimalDataProperty(newListing) && this.isMinimalDataProperty(existingListing)) {
          if (this.addressesSimilar(newAddr, existingAddr)) {
            log.info(`üö´ DUPLICATE DETECTED: Similar addresses for minimal data properties - "${newAddr}" vs "${existingAddr}"`);
            return true;
          }
        }
      }
      
      // Quaternary check: Same price + beds + baths + sqft (very strong indicators)
      if (newListing.price && existingListing.price && 
          newListing.beds && existingListing.beds &&
          newListing.baths && existingListing.baths &&
          newListing.sqft && existingListing.sqft) {
        
        if (newListing.price === existingListing.price &&
            newListing.beds === existingListing.beds &&
            newListing.baths === existingListing.baths &&
            newListing.sqft === existingListing.sqft) {
          log.debug(`üö´ DUPLICATE DETECTED: Same price/beds/baths/sqft ${newListing.price}-${newListing.beds}/${newListing.baths}-${newListing.sqft}sqft`);
          return true; // All key characteristics match = likely duplicate
        }
      }
      
      // Fallback check: Same price + beds + baths (medium strength)
      if (newListing.price && existingListing.price && 
          newListing.beds && existingListing.beds &&
          newListing.baths && existingListing.baths) {
        
        if (newListing.price === existingListing.price &&
            newListing.beds === existingListing.beds &&
            newListing.baths === existingListing.baths) {
          log.debug(`üö´ DUPLICATE DETECTED: Same price/beds/baths ${newListing.price}-${newListing.beds}/${newListing.baths}`);
          return true; // Same price/beds/baths = likely duplicate
        }
      }
      
      return false; // Not a duplicate
    });
  }

  // Helper method to normalize addresses for comparison
  normalizeAddress(address) {
    if (!address) return '';
    
    return address
      .toLowerCase()
      .trim()
      .replace(/\s+/g, ' ')  // Normalize whitespace
      .replace(/\bst\.?\b/g, 'street')  // Standardize street
      .replace(/\bave\.?\b/g, 'avenue')  // Standardize avenue
      .replace(/\bdr\.?\b/g, 'drive')    // Standardize drive
      .replace(/\brd\.?\b/g, 'road')     // Standardize road
      .replace(/\bln\.?\b/g, 'lane')     // Standardize lane
      .replace(/\bct\.?\b/g, 'court')    // Standardize court
      .replace(/\bblvd\.?\b/g, 'boulevard') // Standardize boulevard
      .replace(/[^\w\s]/g, '')           // Remove punctuation
      .trim();
  }

  // Helper method to check if a property has minimal data (common cause of duplicate detection failure)
  isMinimalDataProperty(listing) {
    return !listing.property_id && 
           !listing.mls && 
           (!listing.price || listing.price === 0) &&
           !listing.beds && 
           !listing.baths && 
           !listing.sqft;
  }

  // Helper method to check if two addresses are similar (for minimal data properties)
  addressesSimilar(addr1, addr2) {
    if (!addr1 || !addr2) return false;
    
    // Exact match (already handled above, but double-check)
    if (addr1 === addr2) return true;
    
    // Remove common variations and check again
    const clean1 = addr1.replace(/\b(street|avenue|drive|road|lane|court|boulevard)\b/g, '').replace(/\s+/g, ' ').trim();
    const clean2 = addr2.replace(/\b(street|avenue|drive|road|lane|court|boulevard)\b/g, '').replace(/\s+/g, ' ').trim();
    
    if (clean1 === clean2) return true;
    
    // Check if one address is contained in the other (partial match)
    const longer = addr1.length > addr2.length ? addr1 : addr2;
    const shorter = addr1.length > addr2.length ? addr2 : addr1;
    
    return longer.includes(shorter) && shorter.length > 5; // Avoid matching very short strings
  }

  // NEW: Check for property duplicates across the entire database
  async checkGlobalPropertyDuplicate(property) {
    try {
      const dbService = await this.waitForDatabaseService();
      if (!dbService) {
        log.debug('‚ö†Ô∏è DatabaseService not available for global duplicate check');
        return false;
      }
      
      // Create the API endpoint URL for checking duplicates
      const response = await fetch(`${dbService.baseUrl}/check-property-duplicate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          property_id: property.property_id,
          mls_number: property.mls,
          address: property.address,
          price: property.price,
          bedrooms: property.beds,
          bathrooms: property.baths,
          square_feet: property.sqft
        })
      });
      
      if (!response.ok) {
        log.warn('Failed to check global property duplicate');
        return false;
      }
      
      const result = await response.json();
      
      if (result.isDuplicate) {
        log.debug(`üö´ GLOBAL DUPLICATE DETECTED: Property exists in database`, {
          property_id: property.property_id,
          address: property.address,
          existing_agents: result.existingProperties?.length || 0
        });
        
        // Log details about existing properties
        if (result.existingProperties) {
          result.existingProperties.forEach((existing, index) => {
            log.debug(`   Existing property ${index + 1}: Agent ${existing.agent_id}, Address: ${existing.address}`);
          });
        }
      }
      
      return result.isDuplicate;
      
    } catch (error) {
      log.warn('Error checking global property duplicate:', error);
      return false; // Don't block extraction if check fails
    }
  }

  // Helper method to get text from nearby elements that might contain status info
  getNearbyElementsText(element) {
    let nearbyText = '';
    
    // Check parent elements
    let parent = element.parentElement;
    for (let i = 0; i < 3 && parent; i++) {
      const parentText = parent.textContent || '';
      if (parentText.length < 500) { // Avoid huge parent text
        nearbyText += ' ' + parentText;
      }
      parent = parent.parentElement;
    }
    
    // Check sibling elements
    const siblings = element.parentElement?.children || [];
    for (let sibling of siblings) {
      if (sibling !== element) {
        const siblingText = sibling.textContent || '';
        if (siblingText.length < 200) { // Avoid huge sibling text
          nearbyText += ' ' + siblingText;
        }
      }
    }
    
    return nearbyText;
  }

  extractDetailedListing(element, index) {
    // Delegate to external ListingsExtractor module
    if (window.ListingsExtractor) {
      const listingsExtractor = new window.ListingsExtractor();
      return listingsExtractor.extractDetailedListing(element, index);
    } else {
      log.error('ListingsExtractor module not loaded, using fallback');
      const text = element.textContent || '';
      const priceMatch = text.match(/\$[\d,]+(?:\.\d+)?[KMB]?/i);
      const addressMatch = text.match(/\d+\s+[\w\s]+(?:St|Ave|Dr|Rd|Ln|Ct|Blvd|Way)/i);
      
      return {
        id: index,
        price: priceMatch ? priceMatch[0] : null,
        address: addressMatch ? addressMatch[0] : null,
        source: 'fallback-extraction'
      };
    }
  }

  extractListingsFromText(listings) {
    const pageText = document.body.textContent;
    
    // Look for patterns like "For sale - 08/14/2025" followed by price and property info
    const listingPatterns = [
      /For sale - \d{2}\/\d{2}\/\d{4}[\s\S]*?\$[\d,]+[\s\S]*?\d+ bed[\s\S]*?\d+ bath[\s\S]*?\d+,?\d* sqft/gi,
      /Sold - \d{2}\/\d{2}\/\d{4}[\s\S]*?\$[\d,]+[\s\S]*?\d+ bed[\s\S]*?\d+ bath[\s\S]*?\d+,?\d* sqft/gi
    ];

    listingPatterns.forEach(pattern => {
      const matches = pageText.match(pattern);
      if (matches) {
        matches.forEach((match, index) => {
          const listing = this.parseListingFromText(match, index);
          if (listing) {
            if (match.toLowerCase().includes('sold')) {
              listings.sold.push(listing);
            } else {
              listings.active.push(listing);
            }
          }
        });
      }
    });
  }

  parseListingFromText(text, index) {
    const priceMatch = text.match(/\$[\d,]+(?:\.\d+)?[KMB]?/i); // FIXED: Support K/M/B + decimals
    const bedMatch = text.match(/(\d+) bed/);
    const bathMatch = text.match(/(\d+) bath/);
    const sqftMatch = text.match(/([\d,]+) sqft/);
    const dateMatch = text.match(/(\d{2}\/\d{2}\/\d{4})/);
    const statusMatch = text.match(/(For sale|Sold)/i);

    if (!priceMatch) return null;

    return {
      id: `text-${index}`,
      price: priceMatch[0],
      beds: bedMatch ? bedMatch[1] : null,
      baths: bathMatch ? bathMatch[1] : null,
      sqft: sqftMatch ? sqftMatch[1] : null,
      status: statusMatch ? statusMatch[1] : 'unknown',
      date: dateMatch ? dateMatch[1] : null,
      source: 'text-extraction'
    };
  }

  extractAddress(element, text) {
    log.debug('üè† Extracting address from element:', element.className);
    
    // DEBUG: Show exactly what we're working with


    
    // STEP 1: Extract from aria-label which often has the cleanest address data
    const linkWithAriaLabel = element.querySelector('a[aria-label*="Community detail"]');
    if (linkWithAriaLabel) {
      const ariaLabel = linkWithAriaLabel.getAttribute('aria-label') || '';

      
      // Extract from patterns like "Community detail for 6547 Nasha in Hillsboro, OR 97123"
      const ariaPattern = /Community detail for\s+(.+)/i;
      const ariaMatch = ariaLabel.match(ariaPattern);
      
      if (ariaMatch) {
        let address = ariaMatch[1].trim();
        // Clean up common issues
        address = address.replace(/\s+in\s+/, ' '); // "6547 Nasha in Hillsboro" -> "6547 Nasha Hillsboro"
        
        // Validate it looks like a real address
        if (address.match(/^\d{3,6}\s+[A-Z]/i) && address.length > 10 && address.length < 80) {

          return this.cleanAddress(address);
        }
      }
    }
    
    // STEP 2: Look for "Community detail for" pattern in the text
    const communityDetailPattern = /Community detail for\s+([^S]+?)(?:Sold|For Sale|Contact)/i;
    const communityMatch = text.match(communityDetailPattern);
    
    if (communityMatch) {
      let address = communityMatch[1].trim();
      address = address.replace(/\s+in\s+/, ' '); // Remove " in " connector
      
      // Validate it's a proper address
      if (address.match(/^\d{3,6}\s+[A-Z]/i) && address.length > 10 && address.length < 80) {

        return this.cleanAddress(address);
      }
    }
    
    // STEP 3: Look for specific address patterns in text nodes
    const addressExtractionPatterns = [
      // Match full addresses like "6547 Nasha Hillsboro, OR 97123"
      /\b\d{3,6}\s+[A-Z][a-zA-Z\s]*[A-Z][a-zA-Z]+,?\s*[A-Z]{2}\s+\d{5}\b/g,
      // Match addresses without ZIP like "6547 Nasha Hillsboro"
      /\b\d{3,6}\s+[A-Z][a-zA-Z\s]*[A-Z][a-zA-Z]+(?!\s*square)/g,
      // Match simpler patterns like "2982 T Springfield"
      /\b\d{3,6}\s+[A-Z]\s+[A-Z][a-zA-Z]+/g
    ];
    
    for (const pattern of addressExtractionPatterns) {
      const matches = text.match(pattern) || [];
      
      for (const match of matches) {
        // Filter out unwanted patterns
        if (!match.match(/square\s*feet?/i) &&
            !match.match(/sqft/i) &&
            !match.match(/bed|bath/i) &&
            !match.includes('$') &&
            !match.match(/lot\s*$/) &&
            match.length > 10 &&
            match.length < 80) {
          

          return this.cleanAddress(match.trim());
        }
      }
    }
    
    // STEP 4: Search through all text nodes for clean addresses
    const walker = document.createTreeWalker(
      element,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      const nodeText = node.textContent.trim();
      if (nodeText.length > 10 && nodeText.length < 80) {
        textNodes.push(nodeText);
      }
    }
    

    
    for (const nodeText of textNodes) {
      // Look for addresses in individual text nodes
      if (nodeText.match(/^\d{3,6}\s+[A-Z]/i) &&
          !nodeText.match(/square\s*feet?/i) &&
          !nodeText.match(/sqft/i) &&
          !nodeText.match(/bed|bath/i) &&
          !nodeText.includes('$') &&
          !nodeText.match(/^Sold\s+-/i) &&
          !nodeText.match(/Contact\s+for\s+price/i)) {
        

        return this.cleanAddress(nodeText);
      }
    }
    
    // STEP 5: Try to extract from href attributes which might contain address info
    const links = element.querySelectorAll('a[href*="realestateandhomes-detail"]');
    for (const link of links) {
      const href = link.getAttribute('href') || '';
      // Extract address from URL patterns if present
      const urlMatch = href.match(/\/([^\/]+)_[A-Z]{2}_\d{5}/);
      if (urlMatch) {
        const addressFromUrl = urlMatch[1].replace(/-/g, ' ');
        if (addressFromUrl.match(/^\d+\s+[A-Z]/i)) {

          return this.cleanAddress(addressFromUrl);
        }
      }
    }
    

    return null;
    
    // ENHANCED: Look for street names with numbers separately  
    const streetPatterns = [
      /(\d+\s+[A-Z][a-zA-Z\s]*(?:St|Ave|Dr|Rd|Ln|Ct|Blvd|Way|Street|Avenue|Drive|Road|Lane|Court|Boulevard|Circle|Place))/gi,
      /(\d+\s+[A-Z][a-zA-Z]+)\s*([A-Z][a-zA-Z\s]+,\s*[A-Z]{2})/gi, // Number + Street, City ST
      /(\d+\s+[A-Z][a-zA-Z\s]+)\s*in\s*([A-Z][a-zA-Z\s]+)/gi, // "123 Main in Portland"
      /(\d+\s+[A-Z][a-zA-Z\s]+[A-Z][a-zA-Z\s]+)/gi // More general pattern
    ];
    
    for (const pattern of streetPatterns) {
      const streetMatches = text.match(pattern);
      if (streetMatches) {

        for (const match of streetMatches) {
          // More strict filtering to avoid bad matches
          if (!match.includes('$') && 
              !match.includes('sqft') && 
              !match.includes('square feet') &&
              !match.includes('bed') && 
              !match.includes('bath') &&
              !match.match(/^\d+\s+\d/) && // Avoid "123 456" patterns
              match.length > 8 && 
              match.length < 60) {
            const address = match.trim();

            return this.cleanAddress(address);
          }
        }
      }
    }
    
    // FALLBACK: Use CSS selectors to find address elements more precisely
    const preciseAddressSelectors = [
      '[data-testid*="address"]',
      '.listing-address',
      '.property-address', 
      '.address',
      'h3', 'h4', // Often contain addresses
      '.sr-only' // Sometimes addresses are in screen reader text
    ];
    
    for (const selector of preciseAddressSelectors) {
      try {
        const addressEl = element.querySelector(selector);
        if (addressEl && addressEl.textContent.trim()) {
          const addressText = addressEl.textContent.trim();

          
          // Check if this looks like a clean address
          if (addressText.length > 10 && 
              addressText.length < 100 &&
              !addressText.includes('$') && 
              !addressText.includes('sqft') &&
              !addressText.includes('square feet') &&
              addressText.match(/\d+\s+[A-Za-z]/)) {

            return this.cleanAddress(addressText);
          }
        }
      } catch (e) {
        // Continue
      }
    }
    
    // ENHANCED FOR SOLD PROPERTIES: Check for sold vs active property structure
    const isSoldProperty = text.includes('Status: Sold') || element.textContent.includes('Status: Sold');

    
    // STEP 0: For SOLD properties, try to find COMPLETE address by combining separated elements
    if (isSoldProperty) {

      
      // Look for number and street name in separate elements
      const allElements = element.querySelectorAll('*');
      let foundNumber = null;
      let foundStreet = null;
      let foundCity = null;
      
      for (const el of allElements) {
        const elText = el.textContent.trim();
        
        // Look for house numbers (standalone numbers 3-6 digits)
        if (!foundNumber && elText.match(/^\d{3,6}$/) && !elText.includes('$')) {
          foundNumber = elText;

        }
        
        // Look for street names (words with common suffixes, but not too long)
        if (!foundStreet && elText.match(/^[A-Z][a-zA-Z\s]+(St|Ave|Dr|Rd|Ln|Ct|Blvd|Way|Street|Avenue|Drive|Road|Lane|Court|Boulevard)\b/i) && 
            elText.length < 50 && !elText.includes('$') && !elText.match(/^\d+$/)) {
          foundStreet = elText;

        }
        
        // Look for city names (Capitalized words, often with state)
        if (!foundCity && elText.match(/^[A-Z][a-zA-Z\s]+,?\s*([A-Z]{2}\s*\d{5})?$/) && 
            elText.length < 40 && !elText.includes('$') && !elText.match(/^\d+$/) && 
            !elText.match(/^(St|Ave|Dr|Rd|Ln|Ct|Blvd|Way|Street|Avenue|Drive|Road|Lane|Court|Boulevard)$/i)) {
          foundCity = elText;

        }
      }
      
      // Combine found components
      if (foundNumber && foundStreet) {
        const combinedAddress = foundCity ? 
          `${foundNumber} ${foundStreet}, ${foundCity}` : 
          `${foundNumber} ${foundStreet}`;

        return this.cleanAddress(combinedAddress);
      }
      
      // Fallback: Look for any element that might contain a complete address
      for (const el of allElements) {
        const elText = el.textContent.trim();
        // Look for text that has both numbers and street indicators
        if (elText.match(/\d+\s+[A-Z][a-zA-Z\s]+(St|Ave|Dr|Rd|Ln|Ct|Blvd|Way)/i) && 
            elText.length > 15 && elText.length < 100 && !elText.includes('$')) {

          return this.cleanAddress(elText);
        }
      }
    }
    
    // STEP 1: Try CSS selectors first - but avoid price elements
    const addressSelectors = [
      '.property-address:not([class*="price"])',
      '.listing-address:not([class*="price"])',
      '.address:not([class*="price"])',
      '[data-testid*="address"]:not([class*="price"])',
      '[data-testid*="location"]:not([class*="price"])',
      '.location:not([class*="price"])',
      '.street-address:not([class*="price"])',
      // Look for actual address elements
      'h3:not([class*="price"])',
      'h4:not([class*="price"])', 
      'span:not([class*="price"])',
      'div:not([class*="price"]) > span:not([class*="price"])'
    ];

    for (const selector of addressSelectors) {
      try {
        const addressEl = element.querySelector(selector);
        if (addressEl && addressEl.textContent.trim()) {
          const addressText = addressEl.textContent.trim();
          

          
          // BASIC filtering - only skip obvious prices  
          if (addressText.includes('$') || 
              addressText.match(/^\$?\d{1,4}(,\d{3})*$/) || 
              addressText.match(/^\d{1,4}$/) || 
              addressText.length < 8) {
            log.debug('üö´ Skipping price content via selector:', addressText);
            continue;
          }
          
          // More lenient check for now to debug
          if (addressText.length > 10) {
            const cleanedAddress = this.cleanAddress(addressText);
            log.debug(`‚úÖ Found address via selector ${selector}: "${cleanedAddress}"`);

            return cleanedAddress;
          }
        }
      } catch (e) {
        continue;
      }
    }

    // STEP 2: Look for street addresses in the raw text with ENHANCED patterns
    const addressPatterns = isSoldProperty ? [
      // For sold properties, be more aggressive in finding addresses
      // Look for ANY number followed by words that could be street names
      /(\d+\s+[A-Z][a-zA-Z\s]*(?:St|Ave|Dr|Rd|Ln|Ct|Blvd|Way|Street|Avenue|Drive|Road|Lane|Court|Boulevard|Circle|Place|Terrace)[\w\s,]*)/gi,
      // Look for street names even without explicit suffixes (common in sold listings)
      /(\d+\s+[A-Z][a-zA-Z\s]{8,50})/gi,
      // Look for patterns like "1234 Main Street, City"
      /(\d+\s+[A-Z][a-zA-Z\s]+,\s*[A-Z][a-zA-Z\s]+)/gi,
      // More permissive: any number + capitalized words
      /(\d+\s+[A-Z][a-zA-Z\s]{5,60})/gi
    ] : [
      // For active properties, use standard patterns
      /(\d+\s+[A-Za-z][A-Za-z\s]*(?:St|Ave|Dr|Rd|Ln|Ct|Blvd|Way|Street|Avenue|Drive|Road|Lane|Court|Boulevard)[\w\s,]*)/gi,
      /(\d+\s+[A-Za-z][A-Za-z\s]{5,40})/gi
    ];
    

    
    for (const pattern of addressPatterns) {
      const matches = text.match(pattern);
      if (matches) {

        for (const match of matches) {
          const trimmedMatch = match.trim();
          
          // Enhanced validation for sold properties
          const minLength = isSoldProperty ? 12 : 15; // More lenient for sold
          const maxLength = isSoldProperty ? 120 : 200; // Allow longer for sold
          
          if (!trimmedMatch.includes('$') && 
              !trimmedMatch.match(/^(Bed|Bath|Sq|Status|Type|Contact)/i) && // Skip property details
              trimmedMatch.length > minLength && 
              trimmedMatch.length < maxLength &&
              !trimmedMatch.match(/^\d+\s+(Bed|Bath|Sq)/i)) { // Skip "3 Beds" patterns
            
            const cleanedAddress = this.cleanAddress(trimmedMatch);

            return cleanedAddress;
          }
        }
      }
    }

    // STEP 3: Look for city, state zip patterns (enhanced for sold properties)
    const cityStatePatterns = isSoldProperty ? [
      // More aggressive patterns for sold properties
      /(\d+\s+[A-Z][a-zA-Z\s]+,\s*[A-Z][a-zA-Z\s]+,\s*[A-Z]{2}\s*\d{5})/g, // Full address with zip
      /(\d+\s+[A-Z][a-zA-Z\s]+,\s*[A-Z][a-zA-Z\s]+,\s*[A-Z]{2})/g, // Full address no zip
      /(\d+\s+[A-Z][a-zA-Z\s]+,\s*[A-Z][a-zA-Z\s]+)/g, // Number + street + city
      /([A-Z][a-zA-Z\s]+,\s*[A-Z]{2}\s*\d{5})/g, // City, state zip
      /([A-Z][a-zA-Z\s]+,\s*[A-Z]{2})/g, // City, state
      // Just city names for sold properties
      /([A-Z][a-zA-Z]{4,20})\s*$/, // Single city name at end
    ] : [
      // Standard patterns for active properties  
      /([A-Z][a-zA-Z\s]+,\s*[A-Z]{2}\s*\d{5})/g,
      /([A-Z][a-zA-Z\s]+,\s*[A-Z]{2})/g
    ];
    
    for (const pattern of cityStatePatterns) {
      const matches = text.match(pattern);
      if (matches) {

        for (const match of matches) {
          if (!match.includes('$') && 
              !match.match(/^(Bed|Bath|Sq|Status|Type)/i) && 
              match.length > 8 && match.length < 100) {

            return this.cleanAddress(match);
          }
        }
      }
    }

    log.debug('‚ùå No valid address found');

    
    return null;
  }

  // SIMPLIFIED for debugging - let's see what we're actually getting
  looksLikeRealAddress(text) {
    if (!text || typeof text !== 'string') return false;
    

    
    // Basic validation - just avoid obvious non-addresses
    if (text.includes('$') || 
        text.match(/^\d{1,4}$/) || 
        text.length < 10) {

      return false;
    }
    
    // LENIENT: Accept anything that has a number + letters for now
    const hasNumber = text.match(/\d+/);
    const hasLetters = text.match(/[A-Za-z]{3,}/);
    
    if (hasNumber && hasLetters) {

      return true;
    }
    

    return false;
  }

  looksLikeAddress(text) {
    // Keep the original method for backward compatibility
    return this.looksLikeRealAddress(text);
  }

  cleanAddress(address) {
    if (!address) return null;
    
    // STEP 1: Handle "Community detail for..." pattern specifically  
    if (address.includes('Community detail for')) {
      const match = address.match(/Community detail for (.+?) in (.+?)(?:,|\s|$)/);
      if (match) {
        const streetAddress = match[1].trim();
        const cityArea = match[2].trim();

        return `${streetAddress}, ${cityArea}`;
      }
      
      // Fallback: try to extract just the address part after "Community detail for"
      const afterDetail = address.replace(/.*Community detail for\s*/i, '');
      if (afterDetail.length > 10) {

        return afterDetail;
      }
    }
    
    // Enhanced address cleaning with multiple patterns
    let cleaned = address
      // Add comma after street suffixes when followed by a capital letter (no space)
      .replace(/(\b(?:St|Ave|Dr|Rd|Ln|Ct|Blvd|Way|Rdg|Pl|Ter|Cir)\b)([A-Z])/g, '$1, $2')
      // Add comma after unit numbers when followed by a capital letter  
      .replace(/(\b(?:Unit|Apt|Suite|#)\s*\d+)([A-Z])/g, '$1, $2')
      // Fix spacing issues - add space after street number if missing
      .replace(/(\d+)([A-Z][a-z])/g, '$1 $2')
      // Clean up multiple spaces and commas
      .replace(/\s+/g, ' ')
      .replace(/,\s*,/g, ',')
      .replace(/^\s*,\s*/, '') // Remove leading comma
      .replace(/\s*,\s*$/, '') // Remove trailing comma
      .trim();
    
    // If the address looks like it's missing spaces between parts, try to fix it
    // Look for patterns like "1234MainStBeverly Hills" 
    if (cleaned.match(/\d+[A-Z][a-z]+[A-Z][a-z]/)) {
      // Try to add spaces before capital letters that look like new words
      cleaned = cleaned.replace(/([a-z])([A-Z][a-z])/g, '$1 $2');
      
      // Add comma before city if we detect city pattern
      cleaned = cleaned.replace(/(\b(?:St|Ave|Dr|Rd|Ln|Ct|Blvd|Way|Rdg|Pl|Ter|Cir)\b)\s*([A-Z][a-z]+\s+[A-Z][a-z]+)/g, '$1, $2');
    }
    
    // Remove any remaining price indicators that might have slipped through
    cleaned = cleaned.replace(/\$[\d,]+\.?\d*/g, '').trim();
    
    // Final cleanup
    cleaned = cleaned.replace(/\s+/g, ' ').replace(/,\s*,/g, ',').trim();
    
    return cleaned || null;
  }

  extractBedrooms(element, text) {
    const bedSelectors = ['.beds', '.bedrooms', '[data-testid*="bed"]'];
    
    for (const selector of bedSelectors) {
      const bedEl = element.querySelector(selector);
      if (bedEl) {
        const bedMatch = bedEl.textContent.match(/(\d+)/);
        if (bedMatch) return bedMatch[1];
      }
    }

    const bedMatch = text.match(/(\d+)\s*bed/i);
    return bedMatch ? bedMatch[1] : null;
  }

  extractBathrooms(element, text) {
    const bathSelectors = ['.baths', '.bathrooms', '[data-testid*="bath"]'];
    
    for (const selector of bathSelectors) {
      const bathEl = element.querySelector(selector);
      if (bathEl) {
        const bathMatch = bathEl.textContent.match(/(\d+(?:\.\d+)?)/);
        if (bathMatch) return bathMatch[1];
      }
    }

    const bathMatch = text.match(/(\d+(?:\.\d+)?)\s*bath/i);
    return bathMatch ? bathMatch[1] : null;
  }

  extractSquareFeet(element, text) {
    const sqftSelectors = ['.sqft', '.square-feet', '[data-testid*="sqft"]'];
    
    for (const selector of sqftSelectors) {
      const sqftEl = element.querySelector(selector);
      if (sqftEl) {
        const sqftMatch = sqftEl.textContent.match(/([\d,]+)\s*(?:sqft|sq\.?\s*ft)/i);
        if (sqftMatch) return sqftMatch[1];
      }
    }

    // Look for sqft pattern more carefully to avoid concatenated numbers
    const sqftPatterns = [
      /([\d,]+)\s*sqft/i,
      /([\d,]+)\s*sq\.?\s*ft/i,
      /(\d{1,2},\d{3})\s*(?:sqft|sq)/i  // Match typical sqft ranges like 1,200-9,999
    ];

    for (const pattern of sqftPatterns) {
      const match = text.match(pattern);
      if (match) {
        const value = match[1];
        // Validate it's a reasonable sqft value (not concatenated prices)
        const numValue = parseInt(value.replace(/,/g, ''));
        if (numValue >= 100 && numValue <= 50000) { // Reasonable sqft range
          return value;
        }
      }
    }

    return null;
  }

  extractListingStatus(element, text) {
    const statusSelectors = ['.status', '.listing-status', '[data-testid*="status"]'];
    
    for (const selector of statusSelectors) {
      const statusEl = element.querySelector(selector);
      if (statusEl && statusEl.textContent.trim()) {
        return statusEl.textContent.trim();
      }
    }

    if (text.toLowerCase().includes('sold')) return 'Sold';
    if (text.toLowerCase().includes('for sale')) return 'For Sale';
    if (text.toLowerCase().includes('pending')) return 'Pending';
    
    return 'Active';
  }

  extractListingImage(element) {
    log.debug('üñºÔ∏è EXTRACTING IMAGES for listing element:', element.className || 'no-class');
    
    // DIAGNOSTIC: Log what images are actually in this element
    const allImages = element.querySelectorAll('img');
    log.debug(`üîç Found ${allImages.length} total images in this element`);
    allImages.forEach((img, i) => {
      log.debug(`   Image ${i+1}: src="${img.src?.substring(0, 100)}", alt="${img.alt}", size="${img.width}x${img.height}"`);
    });
    
    // Enhanced selectors for property images
    const imgSelectors = [
      'img[src*="rdcpix"]', // Realtor.com specific images
      'img[src*="listings"]',
      'img[src*="property"]',
      'img[alt*="property"]',
      'img[alt*="listing"]',
      'img[alt*="photo"]',
      '.property-image img',
      '.listing-image img',
      '.photo img',
      '[data-testid*="image"] img',
      '[data-testid*="photo"] img',
      // MORE AGGRESSIVE: Add broader selectors
      'picture img',
      'figure img',
      '[class*="image"] img',
      '[class*="Image"] img', 
      '[class*="photo"] img',
      '[class*="Photo"] img',
      // Generic image selectors but with size filtering
      'img'
    ];

    const foundImages = [];
    
    for (const selector of imgSelectors) {
      const imageElements = element.querySelectorAll(selector);
      const images = Array.from(imageElements);
      log.debug(`üéØ Selector "${selector}" found ${images.length} images`);
      images.forEach((img, i) => {
        if (img && img.src) {
          const isValid = this.isValidPropertyImage(img);
          log.debug(`   ${isValid ? '‚úÖ' : '‚ùå'} Image ${i+1}: ${img.src.substring(0, 80)} (valid: ${isValid})`);
          if (isValid) {
            const normalizedUrl = this.normalizeImageUrl(img.src);
            if (normalizedUrl && !foundImages.includes(normalizedUrl)) {
              foundImages.push(normalizedUrl);
            }
          }
        }
      });
    }

    log.debug(`üñºÔ∏è FINAL RESULT: Found ${foundImages.length} valid images for this listing:`, foundImages);

    // Return first image for individual listing, or array for multiple
    return foundImages.length > 0 ? foundImages[0] : null;
  }

  isValidPropertyImage(imgData) {
    // Delegate to external PhotoExtractor module
    if (window.PhotoExtractor) {
      const photoExtractor = new window.PhotoExtractor();
      return photoExtractor.isValidPropertyImage(imgData);
    } else {
      log.error('PhotoExtractor module not loaded, using fallback');
      return true; // Fallback to accept image
    }
  }

  getImageRejectionReason(src, alt) {
    if (src.startsWith('data:')) return 'data URL';
    if (src.includes('icon')) return 'icon';
    if (src.includes('logo')) return 'logo';
    if (src.includes('avatar')) return 'avatar';
    if (alt.includes('agent')) return 'agent photo';
    if (alt.includes('profile')) return 'profile photo';
    if (src.length < 10) return 'invalid URL';
    return 'other validation failure';
  }

  extractListingType(element, text) {
    if (text.toLowerCase().includes('worked with seller')) return 'Seller Representative';
    if (text.toLowerCase().includes('worked with buyer')) return 'Buyer Representative';
    if (text.toLowerCase().includes('for sale')) return 'For Sale';
    if (text.toLowerCase().includes('sold')) return 'Sold';
    return 'Unknown';
  }

  extractListingDate(element, text) {
    const dateMatch = text.match(/(\d{2}\/\d{2}\/\d{4})/);
    return dateMatch ? dateMatch[1] : null;
  }

  extractAllListingPhotos(element) {
    // Delegate to external PhotoExtractor module
    if (window.PhotoExtractor) {
      const photoExtractor = new window.PhotoExtractor();
      return photoExtractor.extractAllListingPhotos(element);
    } else {
      log.error('PhotoExtractor module not loaded, using fallback');
      return [];
    }
  }

  // Extract property ID from various sources
  extractPropertyId(element) {
    const text = element.textContent || '';
    const html = element.innerHTML || '';
    
    // Look for MLS numbers or property IDs in text
    const mlsMatch = text.match(/MLS[#:\s]*([A-Z0-9-]+)/i) || 
                     text.match(/ID[#:\s]*([A-Z0-9-]+)/i) ||
                     html.match(/property[_-]?id['":\s]*([A-Z0-9-]+)/i);
    
    if (mlsMatch) return mlsMatch[1];

    // Look for property URLs with IDs
    const linkElement = element.querySelector('a[href*="realestateandhomes-detail"]') ||
                       element.querySelector('a[href*="property"]') ||
                       element.querySelector('a[href*="listing"]');
    
    if (linkElement) {
      const urlMatch = linkElement.href.match(/[M]\d{2}\d{3}-\d{5}/) ||
                       linkElement.href.match(/property[/_](\d+)/) ||
                       linkElement.href.match(/listing[/_]([A-Z0-9-]+)/);
      if (urlMatch) return urlMatch[1] || urlMatch[0];
    }

    return null;
  }

  // Extract property price for matching
  extractPropertyPrice(element) {
    const text = element.textContent || '';
    const priceMatch = text.match(/\$[\d,]+(?:\.\d+)?[KMB]?/i); // FIXED: Support K/M/B + flexible decimals
    return priceMatch ? priceMatch[0] : null;
  }

  // Extract property address for matching
  extractPropertyAddress(element) {
    const text = element.textContent || '';
    // Look for address patterns
    const addressMatch = text.match(/(\d+\s+[^,\n]+(?:St|Ave|Dr|Rd|Ln|Ct|Blvd|Way|Drive|Street|Avenue|Road|Lane|Court|Boulevard)[^,\n]*)/i);
    return addressMatch ? addressMatch[1].trim() : null;
  }

  // Extract images from a specific element with context
  extractImagesFromElement(element, context = 'unknown') {
    const images = [];
    
    // Enhanced selectors for property images
    const imgSelectors = [
      'img[src*="rdcpix"]',
      'img[data-src*="rdcpix"]',
      'img[src*="listings"]',
      'img[alt*="property"]',
      'img[alt*="listing"]',
      '.property-image img',
      '.listing-image img',
      'picture img',
      'img'
    ];

    for (const selector of imgSelectors) {
      const imgElements = element.querySelectorAll(selector);
      
      for (const img of imgElements) {
        const imgSrc = img.src || img.dataset.src || img.dataset.original || img.getAttribute('data-src');
        
        if (imgSrc && this.isValidPropertyImage({src: imgSrc, alt: img.alt || '', element: img})) {
          const normalizedUrl = this.normalizeImageUrl(imgSrc);
          if (normalizedUrl && !images.includes(normalizedUrl)) {
            log.debug(`üì∏ Adding image from ${context}:`, normalizedUrl.substring(normalizedUrl.lastIndexOf('/') + 1));
            images.push(normalizedUrl);
          }
        }
      }
      
      // Stop after finding good images
      if (images.length >= 5) break;
    }

    return images;
  }

  // Find the property card that matches this listing
  findMatchingPropertyCard(element, address, price, propertyId) {
    log.debug('üîç Looking for matching property card...', { address, price, propertyId });
    
    // Enhanced selectors for property cards
    const propertyCardSelectors = [
      '[data-testid*="property-card"]',
      '[data-testid*="listing-card"]',
      '.property-card',
      '.listing-card',
      '[class*="PropertyCard"]',
      '[class*="ListingCard"]',
      '[data-testid="card-content"]',
      'article[data-testid*="property"]',
      '.BasePropertyCard',
      '.PropertyResult'
    ];

    const allCards = document.querySelectorAll(propertyCardSelectors.join(', '));
    log.debug(`üîç Found ${allCards.length} potential property cards to check`);

    for (const card of allCards) {
      const cardText = card.textContent || '';
      let matchScore = 0;
      const reasons = [];

      // Check for exact address match
      if (address && cardText.includes(address)) {
        matchScore += 50;
        reasons.push('exact address');
      }
      // Check for partial address match
      else if (address) {
        const addressParts = address.split(' ');
        const houseNumber = addressParts[0];
        const streetName = addressParts.slice(1, 3).join(' '); // First 2 words of street
        
        if (houseNumber && cardText.includes(houseNumber)) {
          matchScore += 20;
          reasons.push('house number');
        }
        if (streetName && cardText.includes(streetName)) {
          matchScore += 20;
          reasons.push('street name');
        }
      }

      // Check for price match
      if (price && cardText.includes(price)) {
        matchScore += 30;
        reasons.push('exact price');
      }

      // Check for property ID match
      if (propertyId && cardText.includes(propertyId)) {
        matchScore += 40;
        reasons.push('property ID');
      }

      // Check if this card is spatially close to the original element
      if (this.isElementClose(element, card)) {
        matchScore += 15;
        reasons.push('spatial proximity');
      }

      log.debug(`üéØ Card match score: ${matchScore} (${reasons.join(', ')})`);

      // Consider it a match if score is high enough
      if (matchScore >= 40) {
        log.debug('‚úÖ Found matching card with score:', matchScore);
        return card;
      }
    }

    log.debug('‚ùå No matching card found');
    return null;
  }

  // Check if two elements are spatially close
  isElementClose(element1, element2) {
    try {
      const rect1 = element1.getBoundingClientRect();
      const rect2 = element2.getBoundingClientRect();
      
      // Calculate distance between centers
      const dx = (rect1.left + rect1.width/2) - (rect2.left + rect2.width/2);
      const dy = (rect1.top + rect1.height/2) - (rect2.top + rect2.height/2);
      const distance = Math.sqrt(dx*dx + dy*dy);
      
      // Consider close if within 500 pixels
      return distance < 500;
    } catch (e) {
      return false;
    }
  }

  // Extract images from elements near this listing
  extractImagesFromProximity(element, address) {
    const images = [];
    
    // Look in parent containers
    const parentContainers = [
      element.parentElement,
      element.closest('[class*="property"]'),
      element.closest('[class*="listing"]'),
      element.closest('[class*="card"]'),
      element.closest('article'),
      element.closest('[data-testid*="property"]')
    ].filter(container => container && container !== element);

    for (const container of parentContainers) {
      const containerImages = this.extractImagesFromElement(container, 'proximity-parent');
      images.push(...containerImages);
      
      if (images.length >= 3) break;
    }

    // Remove duplicates
    return [...new Set(images)];
  }

  // Extract images by property ID
  extractImagesByPropertyId(propertyId) {
    const images = [];
    
    // Look for images with property ID in the src or data attributes
    const allImages = document.querySelectorAll('img');
    
    for (const img of allImages) {
      const imgSrc = img.src || img.dataset.src || img.getAttribute('data-src') || '';
      
      if (imgSrc.includes(propertyId) && this.isValidPropertyImage({src: imgSrc, alt: img.alt || '', element: img})) {
        const normalizedUrl = this.normalizeImageUrl(imgSrc);
        if (normalizedUrl && !images.includes(normalizedUrl)) {
          log.debug(`üÜî Found image by property ID:`, normalizedUrl.substring(normalizedUrl.lastIndexOf('/') + 1));
          images.push(normalizedUrl);
        }
      }
    }

    return images.slice(0, 5); // Limit to 5 images
  }

  extractListingImage(element) {
    log.debug('Extracting primary image for listing element:', element);
    
    // Use the same logic as extractAllListingPhotos but return only the first image
    const photos = this.extractAllListingPhotos(element);
    return photos.length > 0 ? photos[0] : null;
  }

  extractListingDescription(element, text) {
    // Look for description text
    const descSelectors = [
      '.property-description',
      '.listing-description',
      '.description',
      '.summary',
      '[data-testid*="description"]'
    ];

    for (const selector of descSelectors) {
      const descEl = element.querySelector(selector);
      if (descEl && descEl.textContent.trim()) {
        return descEl.textContent.trim().substring(0, 200); // Limit length
      }
    }

    // Extract description from text patterns
    const sentences = text.split(/[.!?]+/);
    const descriptiveSentences = sentences.filter(sentence => 
      sentence.length > 20 && 
      sentence.length < 150 &&
      !sentence.match(/\$[\d,]+(?:\.\d+)?[KMB]?/i) && // Skip sentences with prices - FIXED
      !sentence.match(/\d+\s*bed/) && // Skip bed/bath info
      sentence.match(/[a-zA-Z]/) // Must contain letters
    );

    return descriptiveSentences.length > 0 ? descriptiveSentences[0].trim() : null;
  }

  extractPropertyType(element, text) {
    const typePatterns = [
      /\b(house|home|condo|townhouse|apartment|villa|mansion|estate|duplex|triplex)\b/i,
      /\b(single family|multi family|condominium)\b/i
    ];

    for (const pattern of typePatterns) {
      const match = text.match(pattern);
      if (match) {
        return match[1];
      }
    }

    // Default based on price range
    const priceMatch = text.match(/\$[\d,]+(?:\.\d+)?[KMB]?/i); // FIXED: Support K/M/B + decimals
    if (priceMatch) {
      let price = parseFloat(priceMatch[0].replace(/[$,]/g, '')); // FIXED: Use parseFloat
      if (priceMatch[0].toUpperCase().includes('K')) price *= 1000;
      if (priceMatch[0].toUpperCase().includes('M')) price *= 1000000;
      if (priceMatch[0].toUpperCase().includes('B')) price *= 1000000000;
      
      if (price > 10000000) return 'Luxury Estate';
      if (price > 5000000) return 'High-End Home';
      if (price > 2000000) return 'Premium Home';
      if (price < 1000000) return 'Condo/Townhouse';
    }

    return 'Residential Property';
  }

  extractSpecializations() {
    const specializations = [];
    
    // Enhanced specialization extraction
    const specializationElements = document.querySelectorAll([
      '[data-testid="specialization"]',
      '.specialization',
      '.expertise-area',
      '.specialty-tag',
      '.specializations li',
      '.expertise li'
    ].join(', '));

    specializationElements.forEach(el => {
      const text = el.textContent?.trim();
      if (text) specializations.push(text);
    });

    // Also try to extract from text content if structured elements not found
    if (specializations.length === 0) {
      const pageText = document.body.textContent;
      const specializationKeywords = [
        '2nd homes', 'Buyer\'s agent', 'First time home buyers', 
        'Lake homes', 'Moosehead Lake', 'Seller\'s agent', 
        'vacation homes', 'Views', 'Waterfront'
      ];
      
      specializationKeywords.forEach(keyword => {
        if (pageText.includes(keyword)) {
          specializations.push(keyword);
        }
      });
    }

    return specializations;
  }

  extractTeamInfo() {
    const teamInfo = {};
    
    // TEMPORARILY DISABLE team button clicking to prevent navigation issues
    // const buttonClicked = this.clickShowTeamButton();
    const buttonClicked = false; // Temporarily disabled
    
    // If button was clicked, wait a moment for content to load
    if (buttonClicked) {
      // Use a small delay to allow content to load
      // Note: In a real implementation, you might want to use proper async/await
      // For now, we'll extract immediately but log that we clicked
      log.debug('‚è≥ Waiting for team content to load after button click...');
    }
    
    // Extract team information (whether button was clicked or not)
    teamInfo.name = this.extractCleanTeamName();
    teamInfo.description = this.extractCleanTeamDescription();
    teamInfo.members = this.extractTeamMembers();
    
    // Team photo - normalized URL
    teamInfo.photo = this.normalizeImageUrl(this.getAttribute([
      '.team-photo img',
      'img[alt*="team"]',
      'img[src*="team"]'
    ], 'src'));

    return teamInfo;
  }

  clickShowTeamButton() {
    log.debug('üîç Looking for "Show Team" button...');
    
    // Look for various "Show Team" button patterns
    const buttonSelectors = [
      'button[aria-label*="Show Team"]',
      'button[aria-label*="show team"]',
      'button:contains("Show Team")',
      'a[aria-label*="Show Team"]',
      'a[aria-label*="show team"]',
      '[data-testid*="show-team"]',
      '[data-testid*="team-expand"]',
      'button[class*="show-team"]',
      'button[class*="team-toggle"]'
    ];
    
    for (const selector of buttonSelectors) {
      try {
        const button = document.querySelector(selector);
        if (button) {
          log.debug(`‚úÖ Found "Show Team" button with selector: ${selector}`);
          button.click();
          log.debug('üéØ Clicked "Show Team" button');
          return true;
        }
      } catch (error) {
        // Continue to next selector
      }
    }
    
    // Also try to find buttons by text content
    const allButtons = document.querySelectorAll('button, a');
    for (const button of allButtons) {
      const text = button.textContent?.toLowerCase() || '';
      const ariaLabel = button.getAttribute('aria-label')?.toLowerCase() || '';
      
      if (text.includes('show team') || ariaLabel.includes('show team') || 
          text.includes('view team') || ariaLabel.includes('view team') ||
          text.includes('see team') || ariaLabel.includes('see team')) {
        log.debug(`‚úÖ Found "Show Team" button by text: "${button.textContent}"`);
        button.click();
        log.debug('üéØ Clicked "Show Team" button');
        return true;
      }
    }
    
    log.debug('‚ùå No "Show Team" button found');
    return false;
  }

  extractCleanTeamName() {
    log.debug('üè∑Ô∏è Looking for team name...');
    
    const pageText = document.body.textContent;
    
    // Skip obvious button text
    const skipWords = ['Show Team', 'View Team', 'See Team', 'Hide Team', 'Close Team'];
    
    // Look for team name patterns in various selectors
    const teamNameSelectors = [
      '[data-testid*="team-name"]',
      '.team-name',
      '.team-title',
      'h1[class*="team"]',
      'h2[class*="team"]',
      'h3[class*="team"]',
      '[class*="TeamName"]'
    ];
    
    for (const selector of teamNameSelectors) {
      try {
        const element = document.querySelector(selector);
        if (element) {
          const teamName = element.textContent?.trim();
          if (teamName && !skipWords.includes(teamName) && teamName.length < 100) {
            log.debug(`‚úÖ Found team name from selector ${selector}: "${teamName}"`);
            return teamName;
          }
        }
      } catch (error) {
        // Continue to next selector
      }
    }
    
    // Look for "Live Maine Team" specifically (existing logic)
    if (pageText.includes('Live Maine Team')) {
      log.debug('‚úÖ Found team name: "Live Maine Team"');
      return 'Live Maine Team';
    }
    
    // Look for other team name patterns
    const teamPatterns = [
      /([A-Z][a-zA-Z\s]{2,30}Team)(?:\s|$)/g,
      /([A-Z][a-zA-Z\s]+(?:Real Estate|Realty)\s+Team)(?:\s|$)/g,
      /([A-Z][a-zA-Z\s]+Group)(?:\s|$)/g,
      /(The\s+[A-Z][a-zA-Z\s]+Team)(?:\s|$)/g
    ];
    
    for (const pattern of teamPatterns) {
      const matches = pageText.match(pattern);
      if (matches) {
        for (const match of matches) {
          const teamName = match.trim();
          // Filter out button text and overly generic matches
          if (!skipWords.some(skip => teamName.includes(skip)) && 
              teamName.length > 5 && teamName.length < 50 &&
              !teamName.includes('Show') && !teamName.includes('View')) {
            log.debug(`‚úÖ Found team name from pattern: "${teamName}"`);
            return teamName;
          }
        }
      }
    }
    
    log.debug('‚ùå No valid team name found');
    return null;
  }

  extractCleanTeamDescription() {
    const pageText = document.body.textContent;
    
    // Look for team description starting with "Purchasing or selling"
    const descMatch = pageText.match(/Purchasing or selling[^.]*\./);
    if (descMatch) {
      return descMatch[0].trim();
    }
    
    // Look for other team description patterns
    const aboutTeamMatch = pageText.match(/About [^.]*Team[^.]*\./);
    if (aboutTeamMatch) {
      return aboutTeamMatch[0].trim();
    }
    
    return null;
  }

  extractTeamMembers() {
    log.debug('üë• Looking for team members...');
    
    const members = [];
    
    // Look for team member elements first
    const memberSelectors = [
      '[data-testid*="team-member"]',
      '.team-member',
      '.team-agent',
      '[class*="TeamMember"]',
      '[class*="team-card"]',
      '.agent-card'
    ];
    
    for (const selector of memberSelectors) {
      try {
        const memberElements = document.querySelectorAll(selector);
        if (memberElements.length > 0) {
          log.debug(`üîç Found ${memberElements.length} team member elements with selector: ${selector}`);
          
          memberElements.forEach(element => {
            // Try to extract name from various sub-elements
            const nameSelectors = [
              '.name',
              '.agent-name',
              'h3',
              'h4',
              '[class*="name"]',
              '[data-testid*="name"]'
            ];
            
            for (const nameSelector of nameSelectors) {
              const nameElement = element.querySelector(nameSelector);
              if (nameElement) {
                const memberName = nameElement.textContent?.trim();
                if (memberName && memberName.length > 2 && memberName.length < 50 && 
                    !members.includes(memberName) && !memberName.includes('Show') && 
                    !memberName.includes('View') && !memberName.includes('Hide')) {
                  log.debug(`‚úÖ Found team member: "${memberName}"`);
                  members.push(memberName);
                  break;
                }
              }
            }
          });
        }
      } catch (error) {
        // Continue to next selector
      }
    }
    
    // If no members found from elements, fall back to text pattern matching
    if (members.length === 0) {
      log.debug('üîç Falling back to text pattern matching for team members...');
      
      const pageText = document.body.textContent;
      
      // More specific patterns for real estate agent names
      const namePatterns = [
        // Existing specific names
        /Jim\s+(?:&\s+)?(?:Charlie\s+)?Quimby/g,
        /Charlie\s+Quimby/g,
        /Angie\s+Roberts/g,
        /Manda\s+Stewart/g,
        
        // Generic patterns with better filtering
        /(?:Agent|REALTOR¬Æ?|Associate):\s+([A-Z][a-z]+\s+[A-Z][a-z]+)/gi,
        /([A-Z][a-z]+\s+[A-Z][a-z]+)\s+(?:REALTOR¬Æ?|Agent|Associate)/gi,
        /Team\s+Member:\s+([A-Z][a-z]+\s+[A-Z][a-z]+)/gi,
        /([A-Z][a-z]+\s+[A-Z][a-z]+)\s+-\s+(?:Real Estate|Realtor|Agent)/gi
      ];
      
      // Words to exclude (not real names)
      const excludeWords = [
        'Show Team', 'View Team', 'See Team', 'Hide Team', 'Review Your',
        'Contact Us', 'About Us', 'Get Started', 'Learn More', 'Find Out',
        'Real Estate', 'Property Search', 'Home Search', 'Market Report',
        'Price Range', 'Square Feet', 'Listing Agent', 'Buyer Agent',
        'Show More', 'Read More', 'See All', 'View All', 'Load More'
      ];
      
      namePatterns.forEach(pattern => {
        const matches = pageText.match(pattern);
        if (matches) {
          matches.forEach(match => {
            let cleanName = match.trim();
            
            // Clean up the name (remove titles and prefixes)
            cleanName = cleanName.replace(/^(?:Agent|REALTOR¬Æ?|Associate|Team\s+Member):\s*/i, '').trim();
            cleanName = cleanName.replace(/\s+(?:REALTOR¬Æ?|Agent|Associate|Real Estate|Realtor).*$/i, '').trim();
            cleanName = cleanName.replace(/\s+-\s+.*$/i, '').trim();
            
            // Validate the name
            if (cleanName && 
                cleanName.length > 3 && 
                cleanName.length < 50 && 
                !excludeWords.some(exclude => cleanName.includes(exclude)) &&
                /^[A-Z][a-z]+\s+[A-Z][a-z]+$/.test(cleanName) && // Must be "Firstname Lastname" format
                !members.includes(cleanName)) {
              log.debug(`‚úÖ Found team member from text: "${cleanName}"`);
              members.push(cleanName);
            }
          });
        }
      });
    }
    
    log.debug(`üèÜ Total team members found: ${members.length}`);
    return members;
  }

  extractAllImages() {
    // Delegate to external PhotoExtractor module
    if (window.PhotoExtractor) {
      const photoExtractor = new window.PhotoExtractor();
      return photoExtractor.extractAllImages();
    } else {
      log.error('PhotoExtractor module not loaded');
      return {
        agentPhoto: null,
        teamPhoto: null,
        galleryImages: [],
        propertyImages: [],
        allPropertyPhotos: {
          byListing: [],
          allUrls: [],
          metadata: { totalFound: 0, listingsWithPhotos: 0 }
        }
      };
    }
  }

  // New method to extract all property photos from the entire page
  extractAllPropertyPhotosFromPage() {
    // Delegate to external PhotoExtractor module
    if (window.PhotoExtractor) {
      const photoExtractor = new window.PhotoExtractor();
      return photoExtractor.extractAllPropertyPhotosFromPage();
    } else {
      log.error('PhotoExtractor module not loaded, using fallback');
      return {
        byListing: [],
        allUrls: [],
        metadata: {
          totalFound: 0,
          extractedAt: new Date().toISOString(),
          pageUrl: window.location.href
        }
      };
    }
  }

  // Helper method to extract price from text
  extractPrice(text) {
    const priceMatch = text.match(/\$[\d,]+(?:\.\d+)?[KMB]?/i); // FIXED: Support K/M/B + flexible decimals
    return priceMatch ? priceMatch[0] : null;
  }

  normalizeImageUrl(url, isProfile = false) {
    // Delegate to external PhotoExtractor module
    if (window.PhotoExtractor) {
      const photoExtractor = new window.PhotoExtractor();
      return photoExtractor.normalizeImageUrl(url, isProfile);
    } else {
      log.error('PhotoExtractor module not loaded, using fallback');
      return url; // Fallback to original URL
    }
  }

  // Enhanced method to validate image URL accessibility
  async validateImageUrl(url) {
    try {
      const response = await fetch(url, { method: 'HEAD', mode: 'no-cors' });
      return { url, accessible: true, status: 'HEAD request completed' };
    } catch (error) {
      // For realtor.com images, most will fail CORS but are still valid
      if (url.includes('rdcpix') || url.includes('realtor.com')) {
        return { url, accessible: true, status: 'assumed valid (realtor.com domain)' };
      }
      return { url, accessible: false, status: error.message };
    }
  }

  // Method to clean and validate all image URLs in the extracted data
  async validateExtractedImages(agentData) {
    log.debug('üîç Validating extracted image URLs...');
    
    const validationResults = {
      agentPhoto: null,
      teamPhoto: null,
      propertyImages: [],
      validationSummary: {
        totalChecked: 0,
        accessible: 0,
        failed: 0
      }
    };

    // Validate agent photo
    if (agentData.images?.agentPhoto) {
      validationResults.agentPhoto = await this.validateImageUrl(agentData.images.agentPhoto);
      validationResults.validationSummary.totalChecked++;
      if (validationResults.agentPhoto.accessible) {
        validationResults.validationSummary.accessible++;
      } else {
        validationResults.validationSummary.failed++;
      }
    }

    // Validate team photo
    if (agentData.images?.teamPhoto) {
      validationResults.teamPhoto = await this.validateImageUrl(agentData.images.teamPhoto);
      validationResults.validationSummary.totalChecked++;
      if (validationResults.teamPhoto.accessible) {
        validationResults.validationSummary.accessible++;
      } else {
        validationResults.validationSummary.failed++;
      }
    }

    // Validate property images from listings
    if (agentData.listings?.active) {
      for (const listing of agentData.listings.active) {
        if (Array.isArray(listing.photos)) {
          for (const photoUrl of listing.photos.slice(0, 3)) { // Limit validation to first 3 photos per property
            const validation = await this.validateImageUrl(photoUrl);
            validationResults.propertyImages.push({
              property: listing.address || 'Unknown',
              ...validation
            });
            validationResults.validationSummary.totalChecked++;
            if (validation.accessible) {
              validationResults.validationSummary.accessible++;
            } else {
              validationResults.validationSummary.failed++;
            }
          }
        }
      }
    }

    log.debug('‚úÖ Image validation complete:', validationResults.validationSummary);
    return validationResults;
  }

  isValidImageUrl(url) {
    if (!url) return false;
    
    // Check for common image extensions or image hosting patterns
    const imagePatterns = [
      /\.(jpg|jpeg|png|gif|webp|svg)$/i,
      /\/images\//,
      /\/img\//,
      /\.rdc\./,
      /\.rdcpix\./,
      /cloudfront/,
      /amazonaws/
    ];
    
    return imagePatterns.some(pattern => pattern.test(url)) && 
           !url.includes('pixel') && 
           !url.includes('tracking') &&
           !url.includes('analytics');
  }

  extractCredentials() {
    const credentials = [];
    
    const credentialElements = document.querySelectorAll([
      '[data-testid="credential"]',
      '.credential',
      '.certification',
      '.designation'
    ].join(', '));

    credentialElements.forEach(el => {
      const text = el.textContent?.trim();
      if (text) credentials.push(text);
    });

    return credentials;
  }

  extractSocialMedia() {
    log.debug('üîó Looking for social media links...');
    const social = {};
    
    // Enhanced social media selectors
    const socialSelectors = [
      '.social-media a',
      '.social-links a', 
      '.social a',
      '.agent-social a',
      '.contact-social a',
      '.social-icons a',
      '.social-profiles a',
      'a[href*="facebook.com"]',
      'a[href*="linkedin.com"]',
      'a[href*="twitter.com"]',
      'a[href*="x.com"]',
      'a[href*="instagram.com"]',
      'a[href*="youtube.com"]',
      'a[href*="tiktok.com"]',
      '[data-testid*="social"] a',
      '.contact-info a[href*="facebook"]',
      '.contact-info a[href*="linkedin"]',
      '.contact-info a[href*="twitter"]',
      '.contact-info a[href*="instagram"]'
    ];

    // Look for social media links
    const socialElements = document.querySelectorAll(socialSelectors.join(', '));
    
    socialElements.forEach(link => {
      const href = link.href;
      const text = link.textContent?.trim().toLowerCase();
      
      log.debug(`üîç Testing social link: "${href}" (text: "${text}")`);
      
      // Skip generic realtor.com social links and invalid URLs
      if (!href || href.includes('realtor.com') || href.includes('REALTORdotcom') || 
          href.includes('realtordotcom') || href.includes('example.com') || 
          href === '#' || href.startsWith('javascript:')) {
        log.debug(`‚è≠Ô∏è Skipping generic/invalid link: ${href}`);
        return;
      }
      
      // Must be agent-specific links (not site-wide footer links)
      const isAgentSpecific = href.includes('joshua') || href.includes('altman') || 
                             !href.includes('user/RealtorDotCom') && !href.includes('company/realtor');
      
      if (!isAgentSpecific) {
        log.debug(`‚è≠Ô∏è Skipping non-agent-specific link: ${href}`);
        return;
      }
      
      // Extract different social platforms
      if (href.includes('facebook.com') && !social.facebook) {
        social.facebook = href;
        log.debug(`‚úÖ Found Facebook: ${href}`);
      }
      
      if (href.includes('linkedin.com') && !social.linkedin) {
        social.linkedin = href; 
        log.debug(`‚úÖ Found LinkedIn: ${href}`);
      }
      
      if ((href.includes('twitter.com') || href.includes('x.com')) && !social.twitter) {
        social.twitter = href;
        log.debug(`‚úÖ Found Twitter/X: ${href}`);
      }
      
      if (href.includes('instagram.com') && !social.instagram) {
        social.instagram = href;
        log.debug(`‚úÖ Found Instagram: ${href}`);
      }
      
      if (href.includes('youtube.com') && !social.youtube) {
        social.youtube = href;
        log.debug(`‚úÖ Found YouTube: ${href}`);
      }
      
      if (href.includes('tiktok.com') && !social.tiktok) {
        social.tiktok = href;
        log.debug(`‚úÖ Found TikTok: ${href}`);
      }
    });

    // Also search for social URLs in text content
    const pageText = document.body.textContent;
    const socialPatterns = [
      /(https?:\/\/(?:www\.)?facebook\.com\/[^\s<>"']+)/gi,
      /(https?:\/\/(?:www\.)?linkedin\.com\/[^\s<>"']+)/gi,
      /(https?:\/\/(?:www\.)?(?:twitter|x)\.com\/[^\s<>"']+)/gi,
      /(https?:\/\/(?:www\.)?instagram\.com\/[^\s<>"']+)/gi,
      /(https?:\/\/(?:www\.)?youtube\.com\/[^\s<>"']+)/gi,
      /(https?:\/\/(?:www\.)?tiktok\.com\/[^\s<>"']+)/gi
    ];
    
    socialPatterns.forEach(pattern => {
      const matches = pageText.match(pattern);
      if (matches) {
        matches.forEach(url => {
          log.debug(`üîç Testing social URL from text: "${url}"`);
          
          if (url.includes('facebook.com') && !social.facebook) {
            social.facebook = url;
            log.debug(`‚úÖ Found Facebook in text: ${url}`);
          } else if (url.includes('linkedin.com') && !social.linkedin) {
            social.linkedin = url;
            log.debug(`‚úÖ Found LinkedIn in text: ${url}`);
          } else if ((url.includes('twitter.com') || url.includes('x.com')) && !social.twitter) {
            social.twitter = url;
            log.debug(`‚úÖ Found Twitter/X in text: ${url}`);
          } else if (url.includes('instagram.com') && !social.instagram) {
            social.instagram = url;
            log.debug(`‚úÖ Found Instagram in text: ${url}`);
          } else if (url.includes('youtube.com') && !social.youtube) {
            social.youtube = url;
            log.debug(`‚úÖ Found YouTube in text: ${url}`);
          } else if (url.includes('tiktok.com') && !social.tiktok) {
            social.tiktok = url;
            log.debug(`‚úÖ Found TikTok in text: ${url}`);
          }
        });
      }
    });

    log.debug('üîó Final social media links found:', social);
    return social;
  }

  extractPerformanceData() {
    const performance = {};
    
    // Price range information
    performance.priceRange = this.getTextContent([
      '.price-range',
      'div:contains("Price range") + div',
      'div:contains("$29K - $550K")',
      '.price-info'
    ]);

    // Sales volume
    performance.salesVolume = this.getTextContent([
      '[data-testid="sales-volume"]',
      '.sales-volume',
      '.volume-sold',
      'div:contains("volume")'
    ]);

    // Average sale price
    performance.avgSalePrice = this.getTextContent([
      '[data-testid="avg-sale-price"]',
      '.avg-sale-price',
      '.average-price',
      'div:contains("average")'
    ]);

    // Days on market
    performance.avgDaysOnMarket = this.getTextContent([
      '[data-testid="avg-days-market"]',
      '.avg-days-market',
      '.days-on-market',
      'div:contains("days")'
    ]);

    // Extract years of experience from team description
    const pageText = document.body.textContent;
    const experienceMatch = pageText.match(/(\d+)\s+years?/i);
    if (experienceMatch) {
      performance.experienceYears = experienceMatch[1];
    }

    return performance;
  }

  // Helper methods
  getTextContent(selectors, parent = document) {
    if (typeof selectors === 'string') selectors = [selectors];
    
    for (const selector of selectors) {
      try {
        const element = parent.querySelector(selector);
        if (element && element.textContent?.trim()) {
          return element.textContent.trim();
        }
      } catch (e) {
        // Skip invalid selectors
        continue;
      }
    }
    return null;
  }

  getAttribute(selectors, attribute, parent = document) {
    if (typeof selectors === 'string') selectors = [selectors];
    
    for (const selector of selectors) {
      try {
        const element = parent.querySelector(selector);
        if (element && element.getAttribute(attribute)) {
          return element.getAttribute(attribute);
        }
      } catch (e) {
        // Skip invalid selectors
        continue;
      }
    }
    return null;
  }

  getNumberFromText(selectors, parent = document) {
    const text = this.getTextContent(selectors, parent);
    if (!text) return 0;
    
    const match = text.match(/\d+/);
    return match ? parseInt(match[0]) : 0;
  }

  // Advanced text search helper
  findTextNearby(searchText, parent = document) {
    const walker = document.createTreeWalker(
      parent,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    let node;
    while (node = walker.nextNode()) {
      if (node.textContent && node.textContent.includes(searchText)) {
        // Found the text, now look for nearby elements
        const element = node.parentElement;
        if (element) {
          // Try next sibling
          const nextSibling = element.nextElementSibling;
          if (nextSibling && nextSibling.textContent?.trim()) {
            return nextSibling.textContent.trim();
          }
          
          // Try parent's next sibling
          const parentNext = element.parentElement?.nextElementSibling;
          if (parentNext && parentNext.textContent?.trim()) {
            return parentNext.textContent.trim();
          }
          
          // Return the element's own text
          return element.textContent.trim();
        }
      }
    }
    return null;
  }

  // Extract data that appears after specific text
  getTextAfter(searchText, parent = document) {
    const text = parent.textContent;
    const index = text.indexOf(searchText);
    if (index !== -1) {
      const afterText = text.substring(index + searchText.length);
      // Extract until next newline or significant break
      const lines = afterText.split('\n');
      for (let line of lines) {
        line = line.trim();
        if (line && line.length > 0) {
          return line;
        }
      }
    }
    return null;
  }

  // Data cleaning methods
  cleanText(text) {
    if (!text) return null;
    
    // Remove CSS, excessive whitespace, and unwanted characters
    let cleaned = text
      .replace(/\{[^}]*\}/g, '') // Remove CSS blocks
      .replace(/jsx-\d+/g, '') // Remove JSX class names
      .replace(/\s+/g, ' ') // Replace multiple spaces with single space
      .trim();
    
    // If text is too long or contains mixed content, try to extract the main part
    if (cleaned.length > 200 || this.containsMixedContent(cleaned)) {
      // Try to extract the first meaningful part
      const parts = cleaned.split(/[.!?]\s+/);
      if (parts.length > 1) {
        return parts[0].trim() || null;
      }
      
      // Try to extract before common separators
      const separators = ['(207)', 'office', 'Share', 'recommendations', 'RE/MAX'];
      for (const sep of separators) {
        const index = cleaned.indexOf(sep);
        if (index > 0) {
          const beforeSep = cleaned.substring(0, index).trim();
          if (beforeSep.length > 3 && beforeSep.length < 100) {
            return beforeSep;
          }
        }
      }
      
      // Return first 50 characters if still too messy
      return cleaned.substring(0, 50).trim() || null;
    }
    
    return cleaned || null;
  }

  containsMixedContent(text) {
    // Check if text contains mixed content that indicates poor extraction
    const indicators = [
      /\d{3}[\s\-]\d{3}[\s\-]\d{4}/, // Phone numbers
      /recommendations/i,
      /office/i,
      /share/i,
      /profile/i,
      /\.jsx/,
      /\{.*\}/
    ];
    
    return indicators.some(pattern => pattern.test(text));
  }

  extractSpecificText(element, maxLength = 100) {
    if (!element) return null;
    
    // Get all text content including from child elements
    let text = element.textContent || element.innerText || '';

    
    // Clean the text
    text = text.trim()
      .replace(/\s+/g, ' ') // Replace multiple spaces with single space
      .replace(/\n+/g, ' ') // Replace newlines with spaces
      .replace(/\t+/g, ' '); // Replace tabs with spaces
    



        // Limit length if specified
        if (maxLength && text.length > maxLength) {

            text = text.substring(0, maxLength).trim();
            // Try to end at a word boundary, but be smart about names with internal capitals
            const lastSpace = text.lastIndexOf(' ');
            if (lastSpace > maxLength * 0.5) { // Even more lenient threshold
                // Check if we're cutting in the middle of a name with internal capitals
                const afterSpace = text.substring(lastSpace + 1);

                
                // Enhanced pattern to catch various name patterns:
                // Mc/Mac names: McDowell, McDonald, MacArthur
                // O' names: O'Brien, O'Connor  
                // Other internal caps: DeAngelo, LaRue, VanDyke
                const namePattern = /^([A-Z][a-z]*[A-Z][a-z]*|[A-Z]'[A-Z][a-z]*|[A-Z][a-z]+[A-Z][a-z]+)/;
                
                if (namePattern.test(afterSpace)) {

                    // Don't cut here - keep the full text to preserve the name
                } else {

                    text = text.substring(0, lastSpace);
                }
            }
        }

    return text || null;
  }

  cleanPhoneNumber(text) {
    if (!text) return null;
    
    // Extract phone number pattern
    const phoneMatch = text.match(/\(?\d{3}\)?[\s\-]?\d{3}[\s\-]?\d{4}/);
    return phoneMatch ? phoneMatch[0] : null;
  }

  cleanEmail(text) {
    if (!text) return null;
    
    // Extract email pattern
    const emailMatch = text.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/);
    return emailMatch ? emailMatch[0] : null;
  }

  cleanUrl(url) {
    if (!url) return null;
    
    // Ensure URL has protocol
    if (url.startsWith('//')) {
      return 'https:' + url;
    } else if (url.startsWith('/')) {
      return 'https://www.realtor.com' + url;
    } else if (!url.startsWith('http')) {
      return 'https://' + url;
    }
    
    return url;
  }

  findCleanText(searchText) {
    const elements = document.querySelectorAll('*');
    for (const element of elements) {
      const text = element.textContent;
      if (text && text.includes(searchText)) {
        // Look for the cleanest version of the text
        const cleanText = this.cleanText(text);
        if (cleanText && cleanText.includes(searchText) && cleanText.length < 100) {
          return cleanText;
        }
      }
    }
    return null;
  }

  extractPhoneFromText() {
    const pageText = document.body.textContent;
    const phoneMatch = pageText.match(/\(?\d{3}\)?[\s\-]?\d{3}[\s\-]?\d{4}/);
    return phoneMatch ? phoneMatch[0] : null;
  }

  isValidPhoneNumber(phone) {
    if (!phone) return false;
    
    // Remove all non-digit characters to count digits
    const digitsOnly = phone.replace(/\D/g, '');
    
    // Valid US phone numbers should have 10 digits (or 11 with country code)
    return digitsOnly.length === 10 || digitsOnly.length === 11;
  }

  cleanPhoneNumber(phone) {
    if (!phone) return null;
    
    // Remove extra characters and normalize format
    return phone
      .replace(/[^\d\-\(\)\s\+]/g, '') // Keep only digits, dashes, parens, spaces, plus
      .replace(/\s+/g, ' ') // Normalize spaces
      .trim();
  }

  showDataModal(data) {
    // Option 1: Show in separate popup window
    this.showDataInNewWindow(data);
    
    // Option 2: Also show quick summary notification
    this.showExtractionSummary(data);
  }

  forceOpenDataWindow(data) {
    // Use the enhanced showDataInNewWindow method with tab opening and informational design
    log.info('üöÄ Opening enhanced data display...');
    this.showDataInNewWindow(data);
  }

  showDataInNewWindow(data) {
    // Generate extraction summary
    const summary = this.generateExtractionSummary(data);
    
    // Create comprehensive HTML for the data viewer window
        .raw-data { 
            background: #2c3e50; color: #ecf0f1; padding: 20px; border-radius: 10px; 
            font-family: 'Monaco', 'Consolas', monospace; font-size: 12px; 
            max-height: 400px; overflow-y: auto; white-space: pre-wrap;
        }
        .stats-row { display: flex; justify-content: space-around; text-align: center; margin: 20px 0; }
        .stat-item { }
        .stat-number { font-size: 28px; font-weight: 700; color: #3498db; display: block; }
        .stat-label { color: #7f8c8d; font-size: 14px; text-transform: uppercase; }
        .reviews-summary { 
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e); 
            padding: 20px; border-radius: 12px; text-align: center; margin-bottom: 15px;
        }
        .rating-display { font-size: 36px; margin: 10px 0; }
        .recommendations-container { 
            max-height: 400px; overflow-y: auto; 
            border: 1px solid #d5d5d5; border-radius: 8px; padding: 10px;
            background: #fafafa;
        }
        .recommendation { 
            background: #e8f5e8; border-left: 4px solid #27ae60; 
            padding: 12px; margin: 8px 0; border-radius: 8px;
        }
        .recommendation-text { font-style: italic; color: #2c3e50; margin-bottom: 10px; }
        .recommendation-author { font-weight: 600; color: #27ae60; font-size: 14px; }
        .toggle-section { cursor: pointer; user-select: none; }
        .collapsible { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .collapsible.open { max-height: 1000px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè† Real Estate Agent Profile Extraction</h1>
            <p><strong>Agent:</strong> ${agent.name || 'Unknown Agent'}</p>
            <p><strong>URL:</strong> ${window.location.href}</p>
            <p><strong>Extracted:</strong> ${new Date().toLocaleString()}</p>
            <p><strong>Database Status:</strong> ${dbStatus ? '‚úÖ Successfully Saved to CRM' : '‚ùå Database Save Failed'}</p>
        </div>

        <div class="grid">
            <div class="card ${data?.success ? 'status-success' : 'status-error'}">
                <h3>üìä Extraction Summary</h3>
                <div class="stats-row">
                    <div class="stat-item">
                        <span class="stat-number">${activeListings.length}</span>
                        <span class="stat-label">Active Listings</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number">${soldListings.length}</span>
                        <span class="stat-label">Sold Listings</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number">${reviews.count || 0}</span>
                        <span class="stat-label">Reviews</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number">${recommendations.length}</span>
                        <span class="stat-label">Recommendations</span>
                    </div>
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <strong>Status:</strong> ${data?.success ? '‚úÖ SUCCESS' : '‚ùå FAILED'}
                </div>
            </div>

            <div class="card">
                <h3>üë§ Agent Information</h3>
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">Full Name</div>
                        <div class="info-value ${agent.name ? '' : 'info-missing'}">${agent.name || 'Not found'}</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Experience</div>
                        <div class="info-value ${agent.experience ? '' : 'info-missing'}">${agent.experience || 'Not found'}</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Rating</div>
                        <div class="info-value ${agent.rating ? '' : 'info-missing'}">${agent.rating ? agent.rating + '‚≠ê' : 'Not found'}</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Languages</div>
                        <div class="info-value ${agent.languages ? '' : 'info-missing'}">${agent.languages || 'Not found'}</div>
                    </div>
                </div>
                <div class="info-item" style="margin-top: 15px;">
                    <div class="info-label">Biography</div>
                    <div class="info-value ${agent.bio ? '' : 'info-missing'}">${agent.bio || 'Not found'}</div>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h3>üìû Contact Information</h3>
                <div class="info-item">
                    <div class="info-label">Primary Phone</div>
                    <div class="info-value ${contact.phone ? '' : 'info-missing'}">${contact.phone || 'Not found'}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Mobile Phone</div>
                    <div class="info-value ${contact.mobilePhone ? '' : 'info-missing'}">${contact.mobilePhone || 'Not found'}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Email Address</div>
                    <div class="info-value ${contact.email ? '' : 'info-missing'}">${contact.email || 'Not found'}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Website</div>
                    <div class="info-value ${contact.website ? '' : 'info-missing'}">${contact.website ? `<a href="${contact.website}" target="_blank">${contact.website}</a>` : 'Not found'}</div>
                </div>
            </div>

            <div class="card">
                <h3>üè¢ Office Information</h3>
                <div class="info-item">
                    <div class="info-label">Office Name</div>
                    <div class="info-value ${office.name ? '' : 'info-missing'}">${office.name || 'Not found'}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Office Address</div>
                    <div class="info-value ${office.address ? '' : 'info-missing'}">${office.address || 'Not found'}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Office Phone</div>
                    <div class="info-value ${office.phone ? '' : 'info-missing'}">${office.phone || 'Not found'}</div>
                </div>
            </div>
        </div>

        ${reviews.rating ? `
        <div class="card">
            <h3>‚≠ê Reviews & Ratings</h3>
            <div class="reviews-summary">
                <div class="rating-display">${reviews.rating}‚≠ê</div>
                <div><strong>${reviews.count || 0}</strong> Total Reviews</div>
            </div>
            ${recommendations.length > 0 ? `
                <h4>All Recommendations (${recommendations.length}):</h4>
                <div class="recommendations-container">
                ${recommendations.map(rec => {
                    // Use much more generous text display
                    let displayText = rec.text || 'No text available';
                    if (displayText.length > 400) {
                        // Find sentence boundary for smart truncation
                        const truncated = displayText.substring(0, 400);
                        const lastSentenceEnd = Math.max(
                            truncated.lastIndexOf('.'),
                            truncated.lastIndexOf('!'),
                            truncated.lastIndexOf('?')
                        );
                        
                        if (lastSentenceEnd > 200) {
                            displayText = displayText.substring(0, lastSentenceEnd + 1);
                        } else {
                            const lastSpace = truncated.lastIndexOf(' ');
                            displayText = displayText.substring(0, lastSpace > 300 ? lastSpace : 400) + '...';
                        }
                    }
                    
                    return `
                        <div class="recommendation">
                            <div class="recommendation-text">"${displayText}"</div>
                            <div class="recommendation-author">‚Äî ${rec.author || 'Anonymous'}</div>
                        </div>
                    `;
                }).join('')}
                </div>
            ` : '<p style="color: #7f8c8d; font-style: italic; text-align: center;">No recommendations found</p>'}
        </div>
        ` : ''}

        ${activeListings.length > 0 ? `
        <div class="card">
            <h3>üè† Active Listings (${activeListings.length})</h3>
            <div class="listings-grid">
                ${activeListings.slice(0, 6).map((listing, index) => {
                    // Helper function to check if a property value should be displayed
                    const isValidValue = (value) => {
                        if (value === null || value === undefined) return false;
                        if (typeof value === 'string') {
                            const lowerValue = value.toLowerCase().trim();
                            return lowerValue !== '' && 
                                   lowerValue !== 'n/a' && 
                                   lowerValue !== 'na' && 
                                   lowerValue !== 'null' && 
                                   lowerValue !== 'undefined' &&
                                   lowerValue !== '0' &&
                                   lowerValue !== 'none' &&
                                   lowerValue !== 'unknown';
                        }
                        if (typeof value === 'number') {
                            return value > 0;
                        }
                        return true;
                    };
                    
                    // Build property details only for valid values
                    const propertyDetails = [];
                    if (isValidValue(listing.beds)) {
                        propertyDetails.push(`
                            <div class="detail-item">
                                <div class="detail-value">${listing.beds}</div>
                                <div class="detail-label">Bed${listing.beds !== 1 ? 's' : ''}</div>
                            </div>
                        `);
                    }
                    if (isValidValue(listing.baths)) {
                        propertyDetails.push(`
                            <div class="detail-item">
                                <div class="detail-value">${listing.baths}</div>
                                <div class="detail-label">Bath${listing.baths !== 1 ? 's' : ''}</div>
                            </div>
                        `);
                    }
                    if (isValidValue(listing.sqft)) {
                        const formattedSqft = Number(listing.sqft).toLocaleString();
                        propertyDetails.push(`
                            <div class="detail-item">
                                <div class="detail-value">${formattedSqft}</div>
                                <div class="detail-label">Sq Ft</div>
                            </div>
                        `);
                    }
                    
                    const propertyDetailsHTML = propertyDetails.length > 0 ? 
                        `<div class="property-details">${propertyDetails.join('')}</div>` : '';
                    
                    const propertyTypeHTML = isValidValue(listing.propertyType) ? 
                        `<div><strong>Type:</strong> ${listing.propertyType}</div>` : '';
                    
                    const statusHTML = isValidValue(listing.status) ? 
                        `<div><strong>Status:</strong> ${listing.status}</div>` : '';
                    
                    return `
                    <div class="listing-card">
                        <div class="price">${listing.price || 'Price N/A'}</div>
                        <div><strong>Address:</strong> ${listing.address || 'Address not available'}</div>
                        ${propertyDetailsHTML}
                        ${propertyTypeHTML}
                        ${statusHTML}
                    </div>
                `;
                }).join('')}
            </div>
            ${activeListings.length > 6 ? `<p style="text-align: center; color: #7f8c8d; font-style: italic; margin-top: 15px;">... and ${activeListings.length - 6} more active listings</p>` : ''}
        </div>
        ` : ''}

        ${soldListings.length > 0 ? `
        <div class="card">
            <h3>üè† Sold Listings (${soldListings.length})</h3>
            <div class="listings-grid">
                ${soldListings.slice(0, 6).map((listing, index) => {
                    // Helper function to check if a property value should be displayed
                    const isValidValue = (value) => {
                        if (value === null || value === undefined) return false;
                        if (typeof value === 'string') {
                            const lowerValue = value.toLowerCase().trim();
                            return lowerValue !== '' && 
                                   lowerValue !== 'n/a' && 
                                   lowerValue !== 'na' && 
                                   lowerValue !== 'null' && 
                                   lowerValue !== 'undefined' &&
                                   lowerValue !== '0' &&
                                   lowerValue !== 'none' &&
                                   lowerValue !== 'unknown';
                        }
                        if (typeof value === 'number') {
                            return value > 0;
                        }
                        return true;
                    };
                    
                    // Build property details only for valid values
                    const propertyDetails = [];
                    if (isValidValue(listing.beds)) {
                        propertyDetails.push(`
                            <div class="detail-item">
                                <div class="detail-value">${listing.beds}</div>
                                <div class="detail-label">Bed${listing.beds !== 1 ? 's' : ''}</div>
                            </div>
                        `);
                    }
                    if (isValidValue(listing.baths)) {
                        propertyDetails.push(`
                            <div class="detail-item">
                                <div class="detail-value">${listing.baths}</div>
                                <div class="detail-label">Bath${listing.baths !== 1 ? 's' : ''}</div>
                            </div>
                        `);
                    }
                    if (isValidValue(listing.sqft)) {
                        const formattedSqft = Number(listing.sqft).toLocaleString();
                        propertyDetails.push(`
                            <div class="detail-item">
                                <div class="detail-value">${formattedSqft}</div>
                                <div class="detail-label">Sq Ft</div>
                            </div>
                        `);
                    }
                    
                    const propertyDetailsHTML = propertyDetails.length > 0 ? 
                        `<div class="property-details">${propertyDetails.join('')}</div>` : '';
                    
                    const propertyTypeHTML = isValidValue(listing.propertyType) ? 
                        `<div><strong>Type:</strong> ${listing.propertyType}</div>` : '';
                    
                    const statusHTML = 'Sold'; // Sold listings always have status
                    
                    return `
                    <div class="listing-card">
                        <div class="price">${listing.price || 'Contact for price'}</div>
                        <div><strong>Address:</strong> ${listing.address || 'Address not available'}</div>
                        ${propertyDetailsHTML}
                        ${propertyTypeHTML}
                        <div><strong>Status:</strong> ${statusHTML}</div>
                    </div>
                `;
                }).join('')}
            </div>
            ${soldListings.length > 6 ? `<p style="text-align: center; color: #7f8c8d; font-style: italic; margin-top: 15px;">... and ${soldListings.length - 6} more sold listings</p>` : ''}
        </div>
        ` : ''}

        <div class="card">
            <h3 class="toggle-section" onclick="toggleRawData()">üîç Raw Extraction Data (Click to Toggle)</h3>
            <div id="rawDataSection" class="collapsible">
                <div class="raw-data">${JSON.stringify(data, null, 2)}</div>
            </div>
        </div>
    </div>

    <script>
        function toggleRawData() {
            const section = document.getElementById('rawDataSection');
            section.classList.toggle('open');
        }
        
        // Auto-focus and highlight successful extraction
        ${data?.success ? `
        setTimeout(() => {
            document.querySelector('.status-success').style.animation = 'pulse 2s infinite';
        }, 1000);
        ` : ''}
        

    </script>
    
    <style>
        @keyframes pulse {
            0% { box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
            50% { box-shadow: 0 20px 40px rgba(39, 174, 96, 0.3); }
            100% { box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        }
    </style>
</body>
</html>`;

    // Try to open enhanced data window
    const newWindow = window.open('', 'realtorExtraction_' + Date.now(), 
      'width=1400,height=900,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=no,status=no');
    
    if (newWindow) {
      newWindow.document.write(htmlContent);
      newWindow.document.close();
      newWindow.focus();

    } else {
      console.error('‚ùå FAILED TO OPEN WINDOW - POPUP BLOCKED?');
      alert('Popup blocked! Please allow popups for this site and try again.\\n\\nExtracted data:\\n' + JSON.stringify(data, null, 2));
    }
  }

  showDataInNewWindow(data) {
    // Generate extraction summary
    const summary = this.generateExtractionSummary(data);
    
    // Create comprehensive HTML for the data viewer window
    const htmlContent = this.generateDataViewerHTML(data, summary);
    
    // Open in new tab instead of popup window to avoid blocking
    const newTab = window.open('about:blank', '_blank');
    
    if (newTab) {
      newTab.document.write(htmlContent);
      newTab.document.close();
      
      // Add event listeners after content is loaded
      newTab.addEventListener('load', () => {
        this.setupDataViewerListeners(newTab, data);
      });
      
      log.info('üìä Extraction data opened in new tab');
    } else {
      // Fallback to modal if tab opening fails
      log.warn('Tab opening blocked, falling back to modal');
      this.showDataModalFallback(data);
    }
  }

  generateExtractionSummary(data) {
    const summary = {
      total: 0,
      extracted: 0,
      missing: 0,
      quality: 0,
      categories: {}
    };

    // Analyze each data category
    const categories = {
      'Agent Info': data.agent || {},
      'Contact': data.contact || {},
      'Office': data.office || {},
      'Properties': data.listings || [],
      'Reviews': data.reviews || {},
      'Specializations': data.specializations || [],
      'Areas Served': data.areasServed || '',
      'Social Media': data.socialMedia || {},
      'Images': data.images || {}
    };

    Object.entries(categories).forEach(([category, categoryData]) => {
      const analysis = this.analyzeCategoryData(categoryData);
      summary.categories[category] = analysis;
      summary.total += analysis.total;
      summary.extracted += analysis.extracted;
      summary.missing += analysis.missing;
    });

    summary.quality = summary.total > 0 ? (summary.extracted / summary.total * 100).toFixed(1) : 0;
    
    return summary;
  }

  analyzeCategoryData(data) {
    const analysis = { total: 0, extracted: 0, missing: 0, fields: [] };
    
    if (Array.isArray(data)) {
      analysis.total = 1;
      analysis.extracted = data.length > 0 ? 1 : 0;
      analysis.missing = data.length === 0 ? 1 : 0;
      analysis.fields.push({ name: 'items', value: data.length, status: data.length > 0 ? 'success' : 'missing' });
    } else if (typeof data === 'object' && data !== null) {
      Object.entries(data).forEach(([key, value]) => {
        analysis.total++;
        const hasValue = value !== null && value !== undefined && value !== '' && 
                         (Array.isArray(value) ? value.length > 0 : true);
        
        if (hasValue) {
          analysis.extracted++;
          analysis.fields.push({ name: key, value: value, status: 'success' });
        } else {
          analysis.missing++;
          analysis.fields.push({ name: key, value: 'Not extracted', status: 'missing' });
        }
      });
    } else {
      analysis.total = 1;
      const hasValue = data !== null && data !== undefined && data !== '';
      analysis.extracted = hasValue ? 1 : 0;
      analysis.missing = hasValue ? 0 : 1;
      analysis.fields.push({ name: 'value', value: data || 'Not extracted', status: hasValue ? 'success' : 'missing' });
    }
    
    return analysis;
  }

  generateDataViewerHTML(data, summary) {
    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realtor Data Extraction Results</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            color: #333;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
        }
        
        .header {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 25px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-radius: 10px;
            margin-bottom: 25px;
        }
        
        .header h1 { font-size: 28px; margin-bottom: 12px; font-weight: 300; }
        .header .url { opacity: 0.9; font-size: 14px; font-weight: 300; }
        .header .timestamp { opacity: 0.8; font-size: 13px; margin-top: 8px; }
        
        .summary {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
            margin-bottom: 25px;
        }
        
        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }
        
        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border-left: 4px solid;
            transition: transform 0.2s ease;
        }
        
        .stat-card:hover { transform: translateY(-2px); }
        .stat-card.success { border-left-color: #27ae60; }
        .stat-card.warning { border-left-color: #f39c12; }
        .stat-card.danger { border-left-color: #e74c3c; }
        .stat-card.info { border-left-color: #3498db; }
        
        .stat-value { font-size: 32px; font-weight: 300; margin-bottom: 8px; color: #2c3e50; }
        .stat-label { color: #7f8c8d; font-size: 14px; font-weight: 500; }
        
        .quality-meter {
            background: #e9ecef;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .quality-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .actions {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s ease;
        }
        
        .btn:hover { transform: translateY(-1px); }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        
        .content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 25px;
            margin-bottom: 25px;
        }
        
        @media (max-width: 1024px) {
            .content { grid-template-columns: 1fr; }
        }
        
        .category-card {
            background: white;
            border-radius: 10px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.08);
            overflow: hidden;
            margin-bottom: 25px;
            transition: transform 0.2s ease;
        }
        
        .category-card:hover { transform: translateY(-3px); }
        
        .category-header {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .category-title { font-weight: 500; font-size: 18px; }
        
        .category-score {
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 13px;
            font-weight: 600;
            background: rgba(255,255,255,0.2);
        }
        
        .category-content {
            padding: 20px;
            max-height: none;
            overflow: visible;
        }
        
        .field-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 12px 0;
            border-bottom: 1px solid #ecf0f1;
        }
        
        .field-item:last-child { border-bottom: none; }
        
        .field-name {
            font-weight: 600;
            color: #2c3e50;
            min-width: 140px;
            font-size: 14px;
        }
        
        .field-value {
            flex: 1;
            text-align: right;
            margin-left: 15px;
            word-break: break-word;
            font-size: 14px;
        }
        
        .field-value.success { color: #27ae60; }
        .field-value.missing { color: #e74c3c; font-style: italic; }
        
        /* Image display styles */
        .agent-photo {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid #3498db;
            margin: 10px auto;
            display: block;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .property-images {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .property-image {
            width: 100%;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 2px solid #ecf0f1;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .property-image:hover {
            transform: scale(1.05);
            border-color: #3498db;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .image-count {
            background: #3498db;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            display: inline-block;
        }
        
        .reviews-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
        }
        
        .review-item {
            background: white;
            padding: 15px;
            margin-bottom: 12px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .review-text {
            font-size: 14px;
            line-height: 1.5;
            color: #2c3e50;
            margin-bottom: 8px;
            font-style: italic;
        }
        
        .review-author {
            font-size: 12px;
            color: #7f8c8d;
            font-weight: 600;
            text-align: right;
            border-top: 1px solid #ecf0f1;
            padding-top: 8px;
        }
        
        .no-data {
            color: #95a5a6;
            font-style: italic;
            font-size: 13px;
        }
        
        .raw-json {
            background: white;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .raw-json-header {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 1px solid #dee2e6;
            font-weight: 600;
        }
        
        .raw-json-content {
            padding: 0;
            max-height: 600px;
            overflow: auto;
        }
        
        pre {
            background: #f8f9fa;
            padding: 20px;
            margin: 0;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üìä Realtor Data Extraction Results</h1>
        <div class="url">${data.url || window.location.href || 'Unknown URL'}</div>
        <div class="timestamp">
            Extracted: ${new Date(data.extractedAt || Date.now()).toLocaleString()}
        </div>
    </div>

    <div class="summary">
        <div class="summary-stats">
            <div class="stat-card success">
                <div class="stat-value">${summary.extracted}</div>
                <div class="stat-label">Fields Extracted</div>
            </div>
            <div class="stat-card danger">
                <div class="stat-value">${summary.missing}</div>
                <div class="stat-label">Fields Missing</div>
            </div>
            <div class="stat-card ${summary.quality >= 70 ? 'success' : summary.quality >= 40 ? 'warning' : 'danger'}">
                <div class="stat-value">${summary.quality}%</div>
                <div class="stat-label">Data Quality</div>
            </div>
            <div class="stat-card info">
                <div class="stat-value">${Object.keys(summary.categories).length}</div>
                <div class="stat-label">Categories</div>
            </div>
        </div>
        
        <div class="quality-meter">
            <div class="quality-fill" style="width: ${summary.quality}%; background: ${summary.quality >= 70 ? '#27ae60' : summary.quality >= 40 ? '#f39c12' : '#e74c3c'}"></div>
        </div>
        
        <div class="actions">
            <button class="btn btn-primary" onclick="copyToClipboard('json')">üìã Copy JSON</button>
            <button class="btn btn-success" onclick="downloadData('json')">üíæ Download JSON</button>
            <button class="btn btn-info" onclick="downloadData('csv')">üìä Download CSV</button>
            <button class="btn btn-secondary" onclick="toggleRawData()">üîç Toggle Raw Data</button>
        </div>
    </div>

    <div class="content">
        ${this.generateEnhancedDataSections(data, summary)}
    </div>

    <div class="raw-json" id="rawJson" style="display: none;">
        <div class="raw-json-header">üîç Raw JSON Data</div>
        <div class="raw-json-content">
            <pre>${JSON.stringify(data, null, 2)}</pre>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <script>
        const extractedData = ${JSON.stringify(data, null, 2)};
        
        function copyToClipboard(format) {
            const text = format === 'json' ? JSON.stringify(extractedData, null, 2) : convertToCSV(extractedData);
            navigator.clipboard.writeText(text).then(() => {
                showNotification('Data copied to clipboard!');
            });
        }
        
        function downloadData(format) {
            const filename = 'realtor-data-' + Date.now() + '.' + format;
            const content = format === 'json' ? JSON.stringify(extractedData, null, 2) : convertToCSV(extractedData);
            const blob = new Blob([content], { type: format === 'json' ? 'application/json' : 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            showNotification('File downloaded: ' + filename);
        }
        
        function toggleRawData() {
            const rawJson = document.getElementById('rawJson');
            rawJson.style.display = rawJson.style.display === 'none' ? 'block' : 'none';
        }
        
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }
        
        function convertToCSV(data) {
            // Simple CSV conversion - implement as needed
            return JSON.stringify(data, null, 2);
        }
    </script>
</body>
</html>`;
  }

  generateEnhancedDataSections(data, summary) {
    let html = '';
    
    // AGENT INFORMATION SECTION
    const agent = data.agent || {};
    html += `
      <div class="category-card">
        <div class="category-header">
          <div class="category-title">üë§ Agent Information</div>
          <div class="category-score">${this.countExtractedFields(agent)}</div>
        </div>
        <div class="category-content">`;
    
    // Agent photo if available
    if (agent.photo || data.images?.agentPhoto) {
      const photoUrl = agent.photo || data.images.agentPhoto;
      html += `<img src="${photoUrl}" class="agent-photo" alt="Agent Photo" onerror="this.style.display='none'">`;
    }
    
    html += `
          <div class="field-item">
            <div class="field-name">Full Name</div>
            <div class="field-value ${agent.name ? 'success' : 'missing'}">
              ${agent.name || '<span class="no-data">Not found</span>'}
            </div>
          </div>
          <div class="field-item">
            <div class="field-name">Experience</div>
            <div class="field-value ${agent.experience ? 'success' : 'missing'}">
              ${agent.experience || '<span class="no-data">Not found</span>'}
            </div>
          </div>
          <div class="field-item">
            <div class="field-name">Rating</div>
            <div class="field-value ${agent.rating ? 'success' : 'missing'}">
              ${agent.rating || '<span class="no-data">Not found</span>'}
            </div>
          </div>
          <div class="field-item">
            <div class="field-name">Languages</div>
            <div class="field-value ${agent.languages ? 'success' : 'missing'}">
              ${agent.languages || '<span class="no-data">Not found</span>'}
            </div>
          </div>
          <div class="field-item">
            <div class="field-name">License #</div>
            <div class="field-value ${agent.license ? 'success' : 'missing'}">
              ${agent.license || '<span class="no-data">Not found</span>'}
            </div>
          </div>`;
    
    if (agent.bio) {
      const bioText = agent.bio.length > 300 ? agent.bio.substring(0, 300) + '...' : agent.bio;
      html += `
          <div class="field-item">
            <div class="field-name">Biography</div>
            <div class="field-value success" style="text-align: left; font-style: italic;">
              ${bioText}
            </div>
          </div>`;
    }
    
    html += `</div></div>`;
    
    // CONTACT INFORMATION SECTION
    const contact = data.contact || {};
    html += `
      <div class="category-card">
        <div class="category-header">
          <div class="category-title">üìû Contact Information</div>
          <div class="category-score">${this.countExtractedFields(contact)}</div>
        </div>
        <div class="category-content">
          <div class="field-item">
            <div class="field-name">Primary Phone</div>
            <div class="field-value ${contact.phone ? 'success' : 'missing'}">
              ${contact.phone || '<span class="no-data">Not found</span>'}
            </div>
          </div>
          <div class="field-item">
            <div class="field-name">Mobile Phone</div>
            <div class="field-value ${contact.mobilePhone ? 'success' : 'missing'}">
              ${contact.mobilePhone || '<span class="no-data">Not found</span>'}
            </div>
          </div>
          <div class="field-item">
            <div class="field-name">Email Address</div>
            <div class="field-value ${contact.email ? 'success' : 'missing'}">
              ${contact.email ? `<a href="mailto:${contact.email}">${contact.email}</a>` : '<span class="no-data">Not found</span>'}
            </div>
          </div>
          <div class="field-item">
            <div class="field-name">Website</div>
            <div class="field-value ${contact.website ? 'success' : 'missing'}">
              ${contact.website ? `<a href="${contact.website}" target="_blank">${contact.website}</a>` : '<span class="no-data">Not found</span>'}
            </div>
          </div>
        </div>
      </div>`;
    
    // OFFICE INFORMATION SECTION
    const office = data.office || {};
    html += `
      <div class="category-card">
        <div class="category-header">
          <div class="category-title">üè¢ Office Information</div>
          <div class="category-score">${this.countExtractedFields(office)}</div>
        </div>
        <div class="category-content">
          <div class="field-item">
            <div class="field-name">Office Name</div>
            <div class="field-value ${office.name || contact.officeName ? 'success' : 'missing'}">
              ${office.name || contact.officeName || '<span class="no-data">Not found</span>'}
            </div>
          </div>
          <div class="field-item">
            <div class="field-name">Office Address</div>
            <div class="field-value ${office.address || contact.officeAddress ? 'success' : 'missing'}">
              ${office.address || contact.officeAddress || '<span class="no-data">Not found</span>'}
            </div>
          </div>
          <div class="field-item">
            <div class="field-name">Office Phone</div>
            <div class="field-value ${office.phone || contact.officePhone ? 'success' : 'missing'}">
              ${office.phone || contact.officePhone || '<span class="no-data">Not found</span>'}
            </div>
          </div>
        </div>
      </div>`;
    
    // PROPERTY LISTINGS SECTION
    const listings = data.listings || {};
    const activeListings = listings.active || [];
    const soldListings = listings.sold || [];
    const images = data.images || {};
    
    html += `
      <div class="category-card">
        <div class="category-header">
          <div class="category-title">üèòÔ∏è Property Listings</div>
          <div class="category-score">${activeListings.length + soldListings.length} Total</div>
        </div>
        <div class="category-content">
          <div class="field-item">
            <div class="field-name">Active Listings</div>
            <div class="field-value ${activeListings.length > 0 ? 'success' : 'missing'}">
              ${activeListings.length || 0}
            </div>
          </div>
          <div class="field-item">
            <div class="field-name">Sold Listings</div>
            <div class="field-value ${soldListings.length > 0 ? 'success' : 'missing'}">
              ${soldListings.length || 0}
            </div>
          </div>
          <div class="field-item">
            <div class="field-name">Total Properties</div>
            <div class="field-value ${(activeListings.length + soldListings.length) > 0 ? 'success' : 'missing'}">
              ${activeListings.length + soldListings.length}
            </div>
          </div>`;
    
    // Display property images
    const propertyImages = images.propertyImages || [];
    const allPropertyPhotos = images.allPropertyPhotos?.allUrls || [];
    const allImages = [...propertyImages, ...allPropertyPhotos];
    
    if (allImages.length > 0) {
      html += `
          <div class="field-item">
            <div class="field-name">Property Images</div>
            <div class="field-value success">
              <span class="image-count">${allImages.length}</span>
            </div>
          </div>
          <div class="property-images">`;
      
      allImages.slice(0, 12).forEach((imageUrl, index) => {
        html += `<img src="${imageUrl}" class="property-image" alt="Property ${index + 1}" title="Property Image ${index + 1}" onerror="this.style.display='none'">`;
      });
      
      html += `</div>`;
      
      if (allImages.length > 12) {
        html += `<div style="text-align: center; color: #7f8c8d; font-size: 12px; margin-top: 10px;">... and ${allImages.length - 12} more images</div>`;
      }
    }
    
    html += `</div></div>`;
    
    // REVIEWS & RECOMMENDATIONS SECTION
    const reviews = data.reviews || {};
    const recommendations = data.recommendations || reviews.recommendations || [];
    
    html += `
      <div class="category-card">
        <div class="category-header">
          <div class="category-title">‚≠ê Reviews & Recommendations</div>
          <div class="category-score">${recommendations.length} Reviews</div>
        </div>
        <div class="category-content">
          <div class="field-item">
            <div class="field-name">Overall Rating</div>
            <div class="field-value ${reviews.overall?.rating ? 'success' : 'missing'}">
              ${reviews.overall?.rating || '<span class="no-data">Not found</span>'}
            </div>
          </div>
          <div class="field-item">
            <div class="field-name">Review Count</div>
            <div class="field-value ${recommendations.length > 0 ? 'success' : 'missing'}">
              ${recommendations.length || 0}
            </div>
          </div>`;
    
    // Show actual reviews
    if (recommendations.length > 0) {
      html += `<div class="reviews-section">
                <strong>Recent Reviews (${recommendations.length}):</strong>`;
      
      recommendations.slice(0, 5).forEach((rec, index) => {
        const reviewText = rec.text || rec.review || rec.content || 'No review text';
        const previewText = reviewText.length > 250 ? reviewText.substring(0, 250) + '...' : reviewText;
        html += `
          <div class="review-item">
            <div class="review-text">"${previewText}"</div>
            <div class="review-author">‚Äî ${rec.author || rec.name || 'Anonymous'}</div>
          </div>`;
      });
      
      if (recommendations.length > 5) {
        html += `<div style="text-align: center; color: #7f8c8d; font-size: 12px; margin-top: 10px;">... and ${recommendations.length - 5} more reviews</div>`;
      }
      
      html += `</div>`;
    }
    
    html += `</div></div>`;
    
    return html;
  }

  countExtractedFields(obj) {
    if (!obj || typeof obj !== 'object') return '0 Fields';
    const fields = Object.values(obj).filter(value => 
      value !== null && value !== undefined && value !== '' && 
      (Array.isArray(value) ? value.length > 0 : true)
    );
    return `${fields.length} Fields`;
  }

  formatFieldValue(value) {
    if (value === null || value === undefined || value === '') {
      return 'Not extracted';
    }
    
    if (Array.isArray(value)) {
      return value.length + ' items';
    }
    
    if (typeof value === 'object') {
      return 'Object data';
    }
    
    if (typeof value === 'string' && value.length > 100) {
      return value.substring(0, 100) + '...';
    }
    
    return String(value);
  }

  setupDataViewerListeners(windowObj, data) {
    // Additional setup if needed for the new window
    log.debug('Data viewer window setup complete');
  }

  showExtractionSummary(data) {
    const summary = this.generateExtractionSummary(data);
    
    this.showNotification(`
      üìä Extraction Complete!<br>
      ‚úÖ ${summary.extracted} fields extracted<br>
      ‚ùå ${summary.missing} fields missing<br>
      üìà ${summary.quality}% data quality
    `, 5000);
  }

  showDataModalFallback(data) {
    // Enhanced modal fallback with informational design
    const existingModal = document.getElementById('realtor-data-modal');
    if (existingModal) existingModal.remove();

    // Create informational sections
    const agentInfo = this.createAgentInfoSection(data);
    const propertyInfo = this.createPropertyInfoSection(data);
    const contactInfo = this.createContactInfoSection(data);
    const reviewsInfo = this.createReviewsInfoSection(data);
    const rawDataSection = this.createRawDataSection(data);

    const modal = document.createElement('div');
    modal.id = 'realtor-data-modal';
    modal.innerHTML = `
      <div class="modal-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;">
        <div class="modal-content" style="background: white; border-radius: 12px; width: 95%; max-width: 1000px; max-height: 90vh; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,0.15); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
          
          <!-- Header -->
          <div class="modal-header" style="background: linear-gradient(135deg, #2c5aa0 0%, #1a365d 100%); color: white; padding: 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 3px solid #1a365d;">
            <div>
              <h2 style="margin: 0; font-size: 24px; font-weight: 600;">üìä CRM Data Extraction Results</h2>
              <p style="margin: 5px 0 0 0; opacity: 0.9; font-size: 14px;">Comprehensive realtor information extracted</p>
            </div>
            <button class="close-btn" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 24px; cursor: pointer; padding: 8px 12px; border-radius: 6px; transition: all 0.2s;">&times;</button>
          </div>

          <!-- Actions Bar -->
          <div class="actions-bar" style="background: #f8fafc; padding: 15px 20px; border-bottom: 1px solid #e2e8f0; display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
            <span style="color: #64748b; font-weight: 500; margin-right: 10px;">Actions:</span>
            <button id="copy-json-btn" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s;">üìã Copy Data</button>
            <button id="download-json-btn" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s;">üíæ Download</button>
            <button id="open-new-window-btn" style="padding: 8px 16px; background: #f59e0b; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s;">üîó Open in Tab</button>
          </div>

          <!-- Content Body -->
          <div class="modal-body" style="padding: 0; max-height: calc(90vh - 140px); overflow-y: auto;">
            <div style="display: grid; gap: 0; grid-template-columns: 1fr;">
              ${agentInfo}
              ${propertyInfo}
              ${contactInfo}
              ${reviewsInfo}
              ${rawDataSection}
            </div>
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // Add event listeners
    modal.querySelector('.close-btn').addEventListener('click', () => modal.remove());
    modal.querySelector('.modal-overlay').addEventListener('click', (e) => {
      if (e.target === e.currentTarget) modal.remove();
    });

    modal.querySelector('#copy-json-btn').addEventListener('click', () => {
      navigator.clipboard.writeText(JSON.stringify(data, null, 2));
      this.showNotification('Data copied to clipboard!');
    });

    modal.querySelector('#download-json-btn').addEventListener('click', () => {
      this.downloadData(data, 'json');
    });

    modal.querySelector('#open-new-window-btn').addEventListener('click', () => {
      modal.remove();
      this.showDataInNewWindow(data);
    });
  }

  downloadData(data, format) {
    try {
      let content, filename, mimeType;
      
      if (format === 'json') {
        content = JSON.stringify(data, null, 2);
        filename = `realtor-data-${Date.now()}.json`;
        mimeType = 'application/json';
      } else if (format === 'csv') {
        content = this.convertToCSV(data);
        filename = `realtor-data-${Date.now()}.csv`;
        mimeType = 'text/csv';
      }

      log.debug('üìÅ Starting download...', { format, filename, contentLength: content.length });

      // Method 1: Try Chrome downloads API (if available)
      if (typeof chrome !== 'undefined' && chrome.downloads) {
        try {
          const blob = new Blob([content], { type: mimeType });
          const url = URL.createObjectURL(blob);
          
          chrome.downloads.download({
            url: url,
            filename: filename,
            saveAs: true
          }, (downloadId) => {
            if (chrome.runtime.lastError) {
              log.debug('Chrome downloads API failed, trying fallback:', chrome.runtime.lastError);
              this.downloadDataFallback(content, filename, mimeType);
            } else {
              log.debug('‚úÖ Download started with ID:', downloadId);
              this.showNotification(`${format.toUpperCase()} file downloaded!`);
              setTimeout(() => URL.revokeObjectURL(url), 1000);
            }
          });
          return;
        } catch (e) {
          log.debug('Chrome downloads API error, trying fallback:', e);
        }
      }

      // Method 2: Fallback to blob download
      this.downloadDataFallback(content, filename, mimeType);
      
    } catch (error) {
      log.error('Download failed:', error);
      this.showNotification('‚ùå Download failed! Check console for details.');
    }
  }

  downloadDataFallback(content, filename, mimeType) {
    try {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      
      a.style.display = 'none';
      a.href = url;
      a.download = filename;
      a.target = '_blank';
      
      document.body.appendChild(a);
      a.click();
      
      // Clean up
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
      
      log.debug('‚úÖ Fallback download triggered');
      this.showNotification(`üìÅ ${filename} download started!`);
      
    } catch (error) {
      log.error('Fallback download failed:', error);
      
      // Method 3: Last resort - copy to clipboard
      navigator.clipboard.writeText(content).then(() => {
        this.showNotification('üìã Data copied to clipboard (download failed)');
      }).catch(() => {
        this.showNotification('‚ùå Download and clipboard failed');
      });
    }
  }

  convertToCSV(data) {
    const rows = [];
    
    // Flatten the data structure for CSV
    const flatData = this.flattenObject(data);
    
    // Get headers
    const headers = Object.keys(flatData);
    rows.push(headers.join(','));
    
    // Get values
    const values = headers.map(header => {
      let value = flatData[header];
      
      // Handle different data types
      if (value === null || value === undefined) {
        return '';
      }
      
      // Convert to string and clean
      value = String(value);
      
      // Escape commas and quotes in CSV
      if (value.includes(',') || value.includes('"') || value.includes('\n')) {
        value = `"${value.replace(/"/g, '""')}"`;
      }
      
      return value;
    });
    rows.push(values.join(','));
    
    return rows.join('\n');
  }

  flattenObject(obj, prefix = '') {
    const flattened = {};
    
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const newKey = prefix ? `${prefix}.${key}` : key;
        const value = obj[key];
        
        if (value === null || value === undefined) {
          flattened[newKey] = '';
        } else if (Array.isArray(value)) {
          // Handle arrays better
          if (value.length === 0) {
            flattened[newKey] = '';
          } else {
            // Convert array items to strings
            const stringValues = value.map(item => {
              if (typeof item === 'object' && item !== null) {
                // For image objects, extract the URL (check both 'url' and 'src')
                if (item.url) return item.url;
                if (item.src) return item.src;
                // For review objects, extract text
                if (item.text) return item.text.substring(0, 100).replace(/[,"\n]/g, ' ');
                // For member objects, extract name
                if (item.name) return item.name;
                // For listing objects, combine address and price
                if (item.address || item.price) {
                  return `${item.address || ''} ${item.price || ''}`.trim();
                }
                // For other objects, try to get a meaningful string
                const meaningfulValues = Object.values(item)
                  .filter(val => val && typeof val === 'string' && val.trim().length > 0)
                  .join(' ');
                return meaningfulValues.substring(0, 50).replace(/[,"\n]/g, ' ');
              }
              return String(item).replace(/[,"\n]/g, ' ');
            }).filter(item => item && item.trim().length > 0);
            
            flattened[newKey] = stringValues.join('; ');
          }
        } else if (typeof value === 'object') {
          // Recursively flatten objects
          Object.assign(flattened, this.flattenObject(value, newKey));
        } else {
          // Clean text values
          const cleanedValue = typeof value === 'string' ? this.cleanTextForCSV(value) : value;
          flattened[newKey] = cleanedValue;
        }
      }
    }
    
    return flattened;
  }

  cleanTextForCSV(text) {
    if (!text || typeof text !== 'string') return text;
    
    // Enhanced cleaning for review text and descriptions - comprehensive rating metadata removal
    let cleaned = text
      .replace(/\{[^}]*\}/g, '') // Remove CSS blocks
      .replace(/jsx-\d+/g, '') // Remove JSX class names
      
      // Remove overall rating patterns
      .replace(/Overall rating:\s*\d+\.\d+/gi, '') // "Overall rating:4.9"
      .replace(/Overall rating \(\d+\)/gi, '') // "Overall rating (5)" artifacts
      .replace(/Add rating and review\.?/gi, '') // "Add rating and review"
      
      // Remove "Name | Year" prefixes like "Belinda GillisAgoura | 2025"
      .replace(/^[A-Za-z\s]+\s*\|\s*\d{4}\s*/i, '')
      
      // Remove verified review sections
      .replace(/Verified review\s*\d+\.\d+\s*/gi, '')
      
      // Remove rating scores - this needs to be more comprehensive
      .replace(/\d+\.\d+\s+\d+\.\d+\s*[A-Za-z\s&]*\d+\.\d+\s*[A-Za-z\s&]*\d+\.\d+\s*[A-Za-z\s&]*/gi, '') // "5.0 5.0 Responsiveness 5.0 Market expertise..."
      .replace(/^\d+\.\d+\s+\d+\.\d+.*?communication\s*/i, '') // Start of text rating patterns
      .replace(/\b\d+\.\d+\s+\d+\.\d+.*?(Responsiveness|Market expertise|Negotiation skills|Professionalism)/gi, '')
      
      // Remove rating category labels - ENHANCED
      .replace(/ResponsivenessNegotiation skillsProfessionalism and communicationMarket expertise/gi, '') 
      .replace(/Responsiveness\s*Negotiation skills\s*Professionalism and communication\s*Market expertise/gi, '') 
      .replace(/\b(Responsiveness|Negotiation skills|Professionalism and communication|Market expertise)\b/gi, '') 
      .replace(/\b(Responsiveness|Market expertise|Negotiation skills|Professionalism)\s*&?\s*communication\.?\s*$/gi, '') // "Professionalism & communication." at end
      .replace(/^\s*(Professionalism|Responsiveness|Market expertise|Negotiation skills)\s*&?\s*communication\.?\s*/gi, '') // At beginning
      
      // Remove truncation indicators
      .replace(/\.\.\.\s*$/, '') // Remove trailing "..."
      .replace(/\s*\.\.\.\s*Read more.*$/i, '') // Remove "... Read more" patterns
      .replace(/Read more.*$/i, '') // Remove "Read more" endings
      
      // Remove location patterns - BUT PRESERVE YEARS IN TESTIMONIAL TEXT
      .replace(/\b[A-Z][a-z]+,\s*CA\s*/g, '') // Remove "City, CA" location prefixes
      // DON'T remove standalone years - they might be part of testimonial content
      
      // Clean up incomplete sentence beginnings - FIXED
      .replace(/^In\s*,\s*/i, 'In 2018, ') // Fix "In , I was selected" -> "In 2018, I was selected"
      
      // Clean up text formatting
      .replace(/\s+/g, ' ') // Replace multiple spaces with single space
      .replace(/["\n\r]/g, ' ') // Replace quotes and newlines with spaces
      .replace(/^\s*,\s*/, '') // Remove leading commas
      .replace(/\s*,\s*$/, '') // Remove trailing commas
      .replace(/^[\s\d\.\&]+/, '') // Remove leading spaces, numbers, dots, and ampersands
      .trim();
    
    // If text starts with a quote, make sure it's properly formatted
    if (cleaned.startsWith('"') && !cleaned.endsWith('"') && cleaned.length > 10) {
      // Find the end of the actual quote content
      const quoteEnd = cleaned.lastIndexOf('"');
      if (quoteEnd > 0) {
        cleaned = cleaned.substring(0, quoteEnd + 1);
      }
    }
    
    // Return truncated but longer text for reviews - IMPROVED: Complete sentences only
    if (cleaned.length > 1200) {
      // Try to find the last complete sentence within 1200 characters
      const sentences = cleaned.substring(0, 1200).match(/[^.!?]*[.!?]/g);
      if (sentences && sentences.length > 0) {
        // Return complete sentences up to the limit
        const completeSentences = sentences.join(' ');
        return completeSentences;
      }
      // Fallback: truncate at word boundary
      const lastSpace = cleaned.substring(0, 1200).lastIndexOf(' ');
      return cleaned.substring(0, lastSpace > 800 ? lastSpace : 1200);
    }
    
    return cleaned; // Return full text if under limit
  }

  // Helper methods for creating informational sections
  createAgentInfoSection(data) {
    const agent = data.agent || {};
    const photos = data.agentPhotos || [];
    
    return `
      <div class="info-section" style="padding: 20px; border-bottom: 1px solid #e2e8f0;">
        <h3 style="margin: 0 0 15px 0; color: #1e293b; font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
          üë§ Agent Information
        </h3>
        <div style="display: grid; grid-template-columns: auto 1fr; gap: 15px; align-items: start;">
          ${photos.length > 0 ? `
            <div class="agent-photos" style="display: flex; flex-direction: column; gap: 8px;">
              ${photos.slice(0, 3).map(photo => `
                <img src="${photo}" alt="Agent photo" style="width: 80px; height: 80px; border-radius: 8px; object-fit: cover; border: 2px solid #e2e8f0;" onerror="this.style.display='none'">
              `).join('')}
            </div>
          ` : ''}
          <div class="agent-details" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
            ${agent.name ? `<div><strong style="color: #64748b;">Name:</strong> ${agent.name}</div>` : ''}
            ${agent.title ? `<div><strong style="color: #64748b;">Title:</strong> ${agent.title}</div>` : ''}
            ${agent.company ? `<div><strong style="color: #64748b;">Company:</strong> ${agent.company}</div>` : ''}
            ${agent.license ? `<div><strong style="color: #64748b;">License:</strong> ${agent.license}</div>` : ''}
            ${agent.experience ? `<div><strong style="color: #64748b;">Experience:</strong> ${agent.experience}</div>` : ''}
            ${agent.specialties ? `<div><strong style="color: #64748b;">Specialties:</strong> ${agent.specialties}</div>` : ''}
          </div>
        </div>
        ${agent.bio ? `
          <div style="margin-top: 15px; padding: 15px; background: #f8fafc; border-radius: 8px; border-left: 4px solid #3b82f6;">
            <strong style="color: #64748b;">Bio:</strong>
            <p style="margin: 8px 0 0 0; line-height: 1.6; color: #334155;">${agent.bio}</p>
          </div>
        ` : ''}
      </div>
    `;
  }

  createPropertyInfoSection(data) {
    const properties = data.properties || [];
    
    if (properties.length === 0) {
      return `
        <div class="info-section" style="padding: 20px; border-bottom: 1px solid #e2e8f0;">
          <h3 style="margin: 0 0 15px 0; color: #1e293b; font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
            üè† Properties <span style="background: #ef4444; color: white; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: 500;">0 found</span>
          </h3>
          <p style="color: #64748b; margin: 0;">No property listings found on this page.</p>
        </div>
      `;
    }

    return `
      <div class="info-section" style="padding: 20px; border-bottom: 1px solid #e2e8f0;">
        <h3 style="margin: 0 0 15px 0; color: #1e293b; font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
          üè† Properties <span style="background: #10b981; color: white; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: 500;">${properties.length} found</span>
        </h3>
        <div class="properties-grid" style="display: grid; gap: 15px;">
          ${properties.slice(0, 5).map((property, index) => `
            <div style="border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; background: #f8fafc;">
              <div style="display: grid; grid-template-columns: auto 1fr; gap: 15px; align-items: start;">
                ${property.images && property.images.length > 0 ? `
                  <div class="property-images" style="display: flex; flex-wrap: wrap; gap: 8px; max-width: 200px;">
                    ${property.images.slice(0, 4).map(img => `
                      <img src="${img}" alt="Property image" style="width: 60px; height: 60px; border-radius: 6px; object-fit: cover; border: 1px solid #e2e8f0;" onerror="this.style.display='none'">
                    `).join('')}
                  </div>
                ` : ''}
                <div class="property-details" style="min-width: 0;">
                  ${property.address ? `<div style="font-weight: 600; color: #1e293b; margin-bottom: 8px;">${property.address}</div>` : ''}
                  <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px; font-size: 14px;">
                    ${property.price ? `<div><strong style="color: #64748b;">Price:</strong> ${property.price}</div>` : ''}
                    ${property.beds ? `<div><strong style="color: #64748b;">Beds:</strong> ${property.beds}</div>` : ''}
                    ${property.baths ? `<div><strong style="color: #64748b;">Baths:</strong> ${property.baths}</div>` : ''}
                    ${property.sqft ? `<div><strong style="color: #64748b;">Sq Ft:</strong> ${property.sqft}</div>` : ''}
                    ${property.type ? `<div><strong style="color: #64748b;">Type:</strong> ${property.type}</div>` : ''}
                    ${property.status ? `<div><strong style="color: #64748b;">Status:</strong> ${property.status}</div>` : ''}
                  </div>
                </div>
              </div>
            </div>
          `).join('')}
          ${properties.length > 5 ? `
            <div style="text-align: center; padding: 10px; color: #64748b; font-style: italic;">
              ... and ${properties.length - 5} more properties (see raw data below)
            </div>
          ` : ''}
        </div>
      </div>
    `;
  }

  createContactInfoSection(data) {
    const contact = data.contact || {};
    const hasContact = contact.phone || contact.email || contact.website || contact.address;
    
    return `
      <div class="info-section" style="padding: 20px; border-bottom: 1px solid #e2e8f0;">
        <h3 style="margin: 0 0 15px 0; color: #1e293b; font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
          üìû Contact Information ${hasContact ? '' : '<span style="background: #ef4444; color: white; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: 500;">Limited</span>'}
        </h3>
        ${hasContact ? `
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 12px;">
            ${contact.phone ? `<div><strong style="color: #64748b;">Phone:</strong> ${contact.phone}</div>` : ''}
            ${contact.email ? `<div><strong style="color: #64748b;">Email:</strong> ${contact.email}</div>` : ''}
            ${contact.website ? `<div><strong style="color: #64748b;">Website:</strong> <a href="${contact.website}" target="_blank" style="color: #3b82f6;">${contact.website}</a></div>` : ''}
            ${contact.address ? `<div><strong style="color: #64748b;">Address:</strong> ${contact.address}</div>` : ''}
          </div>
        ` : `
          <p style="color: #64748b; margin: 0;">Limited contact information available. Check raw data section for any additional details.</p>
        `}
      </div>
    `;
  }

  createReviewsInfoSection(data) {
    const reviews = data.reviews || [];
    
    return `
      <div class="info-section" style="padding: 20px; border-bottom: 1px solid #e2e8f0;">
        <h3 style="margin: 0 0 15px 0; color: #1e293b; font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
          ‚≠ê Reviews & Testimonials <span style="background: ${reviews.length > 0 ? '#10b981' : '#ef4444'}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: 500;">${reviews.length} found</span>
        </h3>
        ${reviews.length > 0 ? `
          <div class="reviews-grid" style="display: grid; gap: 15px;">
            ${reviews.slice(0, 3).map(review => `
              <div style="border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; background: #f8fafc;">
                ${review.rating ? `<div style="margin-bottom: 8px; color: #f59e0b; font-size: 16px;">${'‚òÖ'.repeat(Math.floor(review.rating))}${'‚òÜ'.repeat(5 - Math.floor(review.rating))} ${review.rating}/5</div>` : ''}
                ${review.author ? `<div style="font-weight: 600; color: #1e293b; margin-bottom: 8px;">${review.author}</div>` : ''}
                ${review.date ? `<div style="color: #64748b; font-size: 12px; margin-bottom: 10px;">${review.date}</div>` : ''}
                ${review.text ? `<p style="margin: 0; line-height: 1.6; color: #334155;">${review.text.length > 200 ? review.text.substring(0, 200) + '...' : review.text}</p>` : ''}
              </div>
            `).join('')}
            ${reviews.length > 3 ? `
              <div style="text-align: center; padding: 10px; color: #64748b; font-style: italic;">
                ... and ${reviews.length - 3} more reviews (see raw data below)
              </div>
            ` : ''}
          </div>
        ` : `
          <p style="color: #64748b; margin: 0;">No reviews or testimonials found on this page.</p>
        `}
      </div>
    `;
  }

  createRawDataSection(data) {
    return `
      <div class="info-section" style="padding: 20px;">
        <details style="cursor: pointer;">
          <summary style="font-size: 18px; font-weight: 600; color: #1e293b; margin-bottom: 15px; display: flex; align-items: center; gap: 8px;">
            üìä Raw Data (JSON) <span style="background: #6366f1; color: white; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: 500;">Click to expand</span>
          </summary>
          <pre style="background: #f1f5f9; padding: 15px; border-radius: 8px; overflow: auto; max-height: 400px; font-size: 12px; line-height: 1.4; border: 1px solid #e2e8f0; margin: 10px 0 0 0;">${JSON.stringify(data, null, 2)}</pre>
        </details>
      </div>
    `;
  }

  showNotification(message) {
    const notification = document.createElement('div');
    notification.textContent = message;
    notification.style.cssText = `
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 10001;
      background: #4caf50;
      color: white;
      padding: 10px 15px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.remove();
    }, 3000);
  }
}

// Initialize the extractor when the page loads
const safeLog = window.log || { 
  info: console.log, 
  debug: console.log, 
  warn: console.warn, 
  error: console.error 
};

safeLog.debug('üîÑ Content script file executed, document.readyState:', document.readyState);

if (document.readyState === 'loading') {
  safeLog.debug('DOM still loading, waiting for DOMContentLoaded...');
  document.addEventListener('DOMContentLoaded', () => {
    safeLog.debug('DOMContentLoaded fired, creating RealtorDataExtractor...');
    window.extractor = new RealtorDataExtractor();
  });
} else {
  safeLog.debug('DOM already loaded, creating RealtorDataExtractor immediately...');
  window.extractor = new RealtorDataExtractor();
}

safeLog.debug('Content script setup complete');

// Store the class globally to prevent redefinition
window.RealtorDataExtractor = RealtorDataExtractor;
